/**
 * Provider Generator
 *
 * Generates a provider library following Effect-based architecture patterns
 * with standardized structure, configuration, and build setup.
 *
 * Uses centralized library generation utilities for consistency.
 */

import {
  Tree,
  formatFiles,
  installPackagesTask,
  names,
  offsetFromRoot,
} from '@nx/devkit';
import type {
  ProviderGeneratorSchema,
  NormalizedProviderOptions,
} from './schema';
import {
  parseTags,
  validateLibraryDoesNotExist,
} from '../../utils/generator-utils';
import {
  generateLibraryFiles,
  type LibraryGeneratorOptions,
} from '../../utils/library-generator-utils';
import { generateErrorsFile } from './templates/errors.template';
import { generateTypesFile } from './templates/types.template';
import { generateValidationFile } from './templates/validation.template';
import { generateServiceFile } from './templates/service.template';
import { generateLayersFile } from './templates/layers.template';
import { generateServiceSpecFile } from './templates/service-spec.template';
import type { ProviderTemplateOptions } from '../../utils/shared/types';

/**
 * Normalize and validate generator options
 */
function normalizeOptions(
  tree: Tree,
  options: ProviderGeneratorSchema,
): NormalizedProviderOptions {
  // Validate required options
  if (!options.name || options.name.trim() === '') {
    throw new Error('Provider name is required');
  }
  if (!options.externalService || options.externalService.trim() === '') {
    throw new Error('External service name is required');
  }

  const projectName = `provider-${names(options.name).fileName}`;
  const directory = options.directory || 'libs/provider';
  const projectRoot = `${directory}/${names(options.name).fileName}`;

  // Validate library doesn't already exist
  validateLibraryDoesNotExist(tree, projectRoot, projectName);

  const nameVariations = names(options.name);
  const projectClassName = `${nameVariations.className}Service`; // Changed from Provider to Service
  const projectConstantName = `${nameVariations.constantName}_SERVICE`;

  // Platform determination
  const platform = options.platform || 'node';
  // Only set includeClientServer when explicitly provided or when platform requires it
  // For universal platform, always generate both client and server
  // For other platforms, use explicit option or undefined (let platform defaults apply)
  const includeClientServer =
    platform === 'universal' ? true : options.includeClientServer;

  // Generate human-readable description
  const description =
    options.description ||
    `${nameVariations.className} provider for ${options.externalService}`;

  // Create standardized tags following {type}-{scope}-{platform}-{service} pattern
  const defaultTags = [
    'type:provider',
    'scope:provider', // Provider scope for external service adapters
    `platform:${platform}`,
    `service:${names(options.externalService).fileName}`,
  ];
  const parsedTags = parseTags(options.tags, defaultTags);

  return {
    name: options.name,
    directory,
    externalService: options.externalService,
    description,
    platform,
    includeClientServer,

    // Computed values
    projectName,
    projectRoot,
    projectClassName,
    projectConstantName,
    parsedTags,
    offsetFromRoot: offsetFromRoot(projectRoot),
  };
}

/**
 * Generate domain-specific template files using code-based templates
 * Only generates files specific to provider pattern (service.ts, errors.ts, layers.ts, etc.)
 * All infrastructure files are now generated by library-generator-utils
 */
function addDomainFiles(tree: Tree, options: NormalizedProviderOptions) {
  const nameVariations = names(options.name);

  const templateOptions: ProviderTemplateOptions = {
    // Naming variants
    name: options.name,
    className: nameVariations.className,
    propertyName: nameVariations.propertyName,
    fileName: nameVariations.fileName,
    constantName: nameVariations.constantName,

    // Library metadata
    libraryType: 'provider',
    packageName: `@custom-repo/${options.projectName}`,
    projectName: options.projectName,
    projectRoot: options.projectRoot,
    sourceRoot: `${options.projectRoot}/src`,
    offsetFromRoot: options.offsetFromRoot,
    description: options.description,
    tags: options.parsedTags,

    // Provider-specific
    externalService: options.externalService,
    platforms: [options.platform],
  };

  const sourceLibPath = `${templateOptions.sourceRoot}/lib`;

  // Generate all provider-specific files using code-based templates
  tree.write(`${sourceLibPath}/errors.ts`, generateErrorsFile(templateOptions));
  tree.write(`${sourceLibPath}/types.ts`, generateTypesFile(templateOptions));
  tree.write(
    `${sourceLibPath}/validation.ts`,
    generateValidationFile(templateOptions),
  );
  tree.write(
    `${sourceLibPath}/service.ts`,
    generateServiceFile(templateOptions),
  );
  tree.write(`${sourceLibPath}/layers.ts`, generateLayersFile(templateOptions));
  tree.write(
    `${sourceLibPath}/service.spec.ts`,
    generateServiceSpecFile(templateOptions),
  );
}

/**
 * Main provider generator function
 *
 * Simplified to use centralized library generation utilities.
 * This ensures consistency across all library types.
 */
export default async function providerGenerator(
  tree: Tree,
  options: ProviderGeneratorSchema,
) {
  const normalizedOptions = normalizeOptions(tree, options);

  // Generate ALL library files using centralized utility
  const libraryOptions: LibraryGeneratorOptions = {
    name: normalizedOptions.name,
    projectName: normalizedOptions.projectName,
    projectRoot: normalizedOptions.projectRoot,
    offsetFromRoot: normalizedOptions.offsetFromRoot,
    libraryType: 'provider',
    platform: normalizedOptions.platform,
    description: normalizedOptions.description,
    tags: normalizedOptions.parsedTags,
    includeClientServer: normalizedOptions.includeClientServer,
    includeEdgeExports: normalizedOptions.platform === 'edge',
    templateData: {
      externalService: normalizedOptions.externalService,
      projectClassName: normalizedOptions.projectClassName,
      projectConstantName: normalizedOptions.projectConstantName,
    },
  };

  await generateLibraryFiles(tree, libraryOptions);

  // Generate domain-specific files (service.ts, errors.ts, layers.ts)
  addDomainFiles(tree, normalizedOptions);

  // Format files and install packages
  await formatFiles(tree);
  return () => {
    installPackagesTask(tree);
  };
}
