/**
 * Contract Events Template
 *
 * Generates events.ts file for contract libraries with domain event
 * definitions using Schema.Class for event-driven architecture.
 *
 * @module monorepo-library-generator/contract/events-template
 */

import { TypeScriptBuilder } from "../../../utils/code-builder"
import type { ContractTemplateOptions } from "../../../utils/types"

/**
 * Generate events.ts file for contract library
 *
 * Creates domain event definitions with:
 * - Base event metadata schemas
 * - Aggregate metadata for event sourcing
 * - CRUD domain events (Created, Updated, Deleted)
 * - Event union types and schema
 * - Factory helper functions
 */
export function generateEventsFile(options: ContractTemplateOptions) {
  const builder = new TypeScriptBuilder()
  const { className, propertyName } = options
  const domainName = propertyName

  // Add file header
  builder.addRaw(createFileHeader(className, domainName))
  builder.addBlankLine()

  // Add imports
  builder.addImports([{ from: "effect", imports: ["Brand", "Schema"] }])

  // ============================================================================
  // SECTION 1: Base Event Metadata
  // ============================================================================

  builder.addSectionComment("Base Event Metadata")

  // EventMetadata schema
  builder.addRaw(`/**
 * Standard metadata for all events
 */
export const EventMetadata = Schema.Struct({
  /** Unique event identifier (auto-generated by database if not provided) */
  eventId: Schema.optional(Schema.UUID).annotations({
    title: "Event ID",
    description: "Unique identifier for this event - auto-generated by database"
  }),
  /** Event type identifier */
  eventType: Schema.String.annotations({
    title: "Event Type",
    description: "Name of the event type"
  }),
  /** Event version for schema evolution */
  eventVersion: Schema.Literal("1.0").annotations({
    title: "Event Version",
    description: "Event schema version for evolution"
  }),
  /** Timestamp when event occurred (defaults to current time) */
  occurredAt: Schema.optionalWith(Schema.Date, { default: () => new Date() }).annotations({
    title: "Occurred At",
    description: "UTC timestamp when the event occurred"
  }),
  /** Optional correlation ID for tracing */
  correlationId: Schema.optional(Schema.UUID).annotations({
    title: "Correlation ID",
    description: "ID to correlate related events across services"
  }),
  /** Optional causation ID (ID of event that caused this one) */
  causationId: Schema.optional(Schema.UUID).annotations({
    title: "Causation ID",
    description: "ID of the event that caused this event"
  })
}).pipe(
  Schema.annotations({
    identifier: "EventMetadata",
    title: "Event Metadata"
  })
)

export type EventMetadata = typeof EventMetadata.Type`)

  // ============================================================================
  // SECTION 2: Aggregate Metadata
  // ============================================================================

  builder.addSectionComment("Aggregate Metadata")

  // AggregateMetadata schema (prefixed with className)
  builder.addRaw(`/**
 * ${className} aggregate metadata for event sourcing
 *
 * Includes aggregate root ID and version for optimistic concurrency.
 */
export const ${className}AggregateMetadata = Schema.Struct({
  /** Aggregate root identifier */
  aggregateId: Schema.String.pipe(Schema.brand("${className}Id")).annotations({
    title: "${className} ID",
    description: "ID of the ${propertyName} aggregate root"
  }),
  /** Aggregate version for optimistic concurrency */
  aggregateVersion: Schema.Number.annotations({
    title: "Aggregate Version",
    description: "Version number for optimistic locking"
  })
}).pipe(
  Schema.annotations({
    identifier: "${className}AggregateMetadata",
    title: "${className} Aggregate Metadata"
  })
)

export type ${className}AggregateMetadata = typeof ${className}AggregateMetadata.Type`)

  // ============================================================================
  // SECTION 3: CRUD Domain Events
  // ============================================================================

  builder.addSectionComment("${className} Domain Events")

  // CreatedEvent with nested metadata/aggregate structure
  builder.addRaw(`/**
 * Event emitted when a new ${propertyName} is created
 */
export class ${className}CreatedEvent extends Schema.Class<${className}CreatedEvent>("${className}CreatedEvent")({
  /** Event metadata */
  metadata: EventMetadata,
  /** Aggregate metadata */
  aggregate: ${className}AggregateMetadata,
  /** Event payload - the created ${propertyName} data */
  payload: Schema.Struct({
    // TODO: Add fields for the created ${propertyName}
    id: Schema.String.pipe(Schema.brand("${className}Id")),
    createdAt: Schema.Date
  })
}) { }`)

  // UpdatedEvent with nested metadata/aggregate structure
  builder.addRaw(`/**
 * Event emitted when a ${propertyName} is updated
 */
export class ${className}UpdatedEvent extends Schema.Class<${className}UpdatedEvent>("${className}UpdatedEvent")({
  /** Event metadata */
  metadata: EventMetadata,
  /** Aggregate metadata */
  aggregate: ${className}AggregateMetadata,
  /** Event payload - the changes made */
  payload: Schema.Struct({
    // TODO: Add fields that were updated
    id: Schema.String.pipe(Schema.brand("${className}Id")),
    updatedAt: Schema.Date,
    changes: Schema.Record({ key: Schema.String, value: Schema.Unknown })
  })
}) { }`)

  // DeletedEvent with nested metadata/aggregate structure
  builder.addRaw(`/**
 * Event emitted when a ${propertyName} is deleted
 */
export class ${className}DeletedEvent extends Schema.Class<${className}DeletedEvent>("${className}DeletedEvent")({
  /** Event metadata */
  metadata: EventMetadata,
  /** Aggregate metadata */
  aggregate: ${className}AggregateMetadata,
  /** Event payload */
  payload: Schema.Struct({
    id: Schema.String.pipe(Schema.brand("${className}Id")),
    deletedAt: Schema.Date
  })
}) { }`)

  // ============================================================================
  // SECTION 4: Event Union Types
  // ============================================================================

  builder.addSectionComment("Event Union Types")

  builder.addRaw(`/**
 * Union of all ${className} domain events
 */
export type ${className}Event =
  | ${className}CreatedEvent
  | ${className}UpdatedEvent
  | ${className}DeletedEvent

/**
 * Schema for all ${className} events (for serialization)
 */
export const ${className}EventSchema = Schema.Union(
  ${className}CreatedEvent,
  ${className}UpdatedEvent,
  ${className}DeletedEvent
)`)

  // ============================================================================
  // SECTION 5: Event Factory Helpers
  // ============================================================================

  builder.addSectionComment("Event Factory Helpers")

  builder.addRaw(`/**
 * Create event metadata with defaults
 */
export function createEventMetadata(
  eventType: string,
  options?: {
    correlationId?: string
    causationId?: string
  }
) {
  return {
    eventType,
    eventVersion: "1.0",
    occurredAt: new Date(),
    ...(options?.correlationId && { correlationId: options.correlationId }),
    ...(options?.causationId && { causationId: options.causationId })
  } satisfies EventMetadata
}

/**
 * Create aggregate metadata
 */
export function createAggregateMetadata(
  aggregateId: string,
  aggregateVersion: number
) {
  return {
    aggregateId: aggregateId as Brand.Branded<string, "${className}Id">,
    aggregateVersion
  } satisfies ${className}AggregateMetadata
}`)

  return builder.toString()
}

/**
 * Create file header
 */
function createFileHeader(className: string, domainName: string) {
  return `/**
 * ${className} Domain Events
 *
 * Defines all domain events for ${domainName} domain operations.
 *
 * @generated This file was generated by monorepo-library-generator
 */`
}
