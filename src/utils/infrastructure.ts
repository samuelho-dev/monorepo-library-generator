/**
 * Unified Infrastructure Generator
 *
 * Single source of truth for infrastructure file generation that works with
 * both Nx (via TreeAdapter) and CLI (via EffectFsAdapter).
 *
 * This generator creates:
 * - package.json (all modes)
 * - tsconfig.json, tsconfig.lib.json, tsconfig.spec.json (all modes)
 * - vitest.config.ts (all modes)
 * - README.md (all modes)
 *
 * Note: CLAUDE.md and project.json are generated by wrapper generators:
 * - CLAUDE.md: Generated by domain-specific core generators
 * - project.json: Written by addProjectConfiguration() in Nx mode
 *
 * Mode-specific behavior is determined by adapter.getMode():
 * - "nx": Returns config for Nx workspace registration via addProjectConfiguration()
 * -: Standalone library without Nx-specific configuration
 *
 * @module monorepo-library-generator/infrastructure
 */

import { Effect } from "effect"
import type { LibraryType } from "./build-config"
import { type ExportConfig, generateGranularExports } from "./exports"
import type { FileSystemAdapter } from "./filesystem-adapter"
import type { PlatformType } from "./platforms"

/**
 * Unified Infrastructure Generation Options
 *
 * All options required for generating complete library infrastructure.
 * Pre-computed by wrapper generators (Nx or CLI).
 */
export interface InfrastructureOptions {
  /**
   * Project name (e.g., "feature-auth", "contract-user")
   */
  readonly projectName: string

  /**
   * Project root directory relative to workspace (e.g., "libs/feature/auth")
   */
  readonly projectRoot: string

  /**
   * Source root directory (e.g., "libs/feature/auth/src")
   */
  readonly sourceRoot?: string

  /**
   * Scoped package name (e.g., "@myorg/feature-auth")
   */
  readonly packageName: string

  /**
   * Human-readable description
   */
  readonly description: string

  /**
   * Library type (determines file structure and exports)
   */
  readonly libraryType: LibraryType

  /**
   * Target platform
   */
  readonly platform: PlatformType

  /**
   * Relative path from project root to workspace root (e.g., "../../..")
   */
  readonly offsetFromRoot: string

  /**
   * Project tags for Nx constraints
   */
  readonly tags: Array<string>

  /**
   * Generate client/server split exports
   */
  readonly includeClientServer?: boolean

  /**
   * Generate RPC functionality
   */
  readonly includeRPC?: boolean

  /**
   * Generate edge runtime support
   */
  readonly includeEdgeExports?: boolean

  /**
   * Entity names for contract libraries (enables granular entity exports)
   */
  readonly entities?: ReadonlyArray<string>
}

/**
 * Infrastructure Generation Result
 *
 * Metadata returned after successful infrastructure generation.
 */
export interface InfrastructureGenerationResult {
  /**
   * Whether the project requires Nx workspace registration
   * (Only true in Nx mode)
   */
  readonly requiresNxRegistration: boolean

  /**
   * Project configuration for Nx registration
   * (Only present if requiresNxRegistration is true)
   */
  readonly projectConfig?: {
    readonly name: string
    readonly root: string
    readonly projectType: "library"
    readonly sourceRoot: string
    readonly tags: Array<string>
    readonly targets: Record<string, unknown>
  }

  /**
   * Files generated during infrastructure phase
   */
  readonly filesGenerated: Array<string>
}

/**
 * Generate Library Infrastructure
 *
 * Main entry point for unified infrastructure generation.
 * Works with any FileSystemAdapter implementation.
 *
 * Behavior is mode-dependent:
 * - Nx mode: Generates infrastructure files, returns config for addProjectConfiguration()
 * - Effect mode: Generates infrastructure files (standalone library)
 *
 * @param adapter - FileSystemAdapter (TreeAdapter or EffectFsAdapter)
 * @param options - Infrastructure generation options
 * @returns Effect with generation result
 */
export function generateLibraryInfrastructure(
  adapter: FileSystemAdapter,
  options: InfrastructureOptions
) {
  return Effect.gen(function*() {
    const mode = adapter.getMode()
    const workspaceRoot = adapter.getWorkspaceRoot()
    const filesGenerated: Array<string> = []

    // Compute source root if not provided
    const sourceRoot = options.sourceRoot || `${options.projectRoot}/src`

    // 1. Generate package.json (all modes)
    yield* generatePackageJsonFile(adapter, workspaceRoot, options)
    filesGenerated.push(`${options.projectRoot}/package.json`)

    // 2. Generate TypeScript configuration files (all modes)
    const tsConfigFiles = yield* generateTsConfigFiles(
      adapter,
      workspaceRoot,
      options
    )
    for (const file of tsConfigFiles) {
      filesGenerated.push(file)
    }

    // 3. Generate vitest configuration (all modes)
    yield* generateVitestConfigFile(adapter, workspaceRoot, options)
    filesGenerated.push(`${options.projectRoot}/vitest.config.ts`)

    // 4. Generate documentation files (all modes)
    const docFiles = yield* generateDocumentationFiles(
      adapter,
      workspaceRoot,
      options
    )
    for (const file of docFiles) {
      filesGenerated.push(file)
    }

    // 5. Generate source file scaffolds (all modes)
    const sourceFiles = yield* generateSourceFileScaffolds(
      adapter,
      workspaceRoot,
      sourceRoot
    )
    for (const file of sourceFiles) {
      filesGenerated.push(file)
    }

    // 6. Prepare Nx registration (Nx mode only)
    // Note: project.json is written by addProjectConfiguration() in the wrapper generator
    if (mode === "nx") {
      // Return metadata for Nx registration
      // The wrapper generator will call addProjectConfiguration() which writes project.json
      return {
        requiresNxRegistration: true,
        projectConfig: createProjectConfiguration(options, sourceRoot),
        filesGenerated
      }
    }

    // Effect mode: No Nx registration needed
    return {
      requiresNxRegistration: false,
      filesGenerated
    }
  })
}

/**
 * Generate package.json file
 *
 * Creates package.json with:
 * - Proper scope extracted from workspace root package.json
 * - Granular exports based on library type and platform
 * - sideEffects: false for tree-shaking
 * - Effect peer dependency
 */
function generatePackageJsonFile(
  adapter: FileSystemAdapter,
  workspaceRoot: string,
  options: InfrastructureOptions
) {
  return Effect.gen(function*() {
    // Build granular exports configuration
    const exportConfig: ExportConfig = {
      libraryType: options.libraryType,
      platform: options.platform,
      ...(options.includeClientServer !== undefined && {
        includeClientServer: options.includeClientServer
      }),
      ...(options.includeEdgeExports !== undefined && {
        includeEdgeExports: options.includeEdgeExports
      }),
      ...(options.includeRPC !== undefined && {
        includeRPC: options.includeRPC
      }),
      hasEntities: Boolean(options.entities && options.entities.length > 0),
      ...(options.entities &&
        options.entities.length > 0 && {
        entityNames: Array.from(options.entities)
      })
    }

    const exports = generateGranularExports(exportConfig)

    // Create package.json content
    const packageJson = {
      name: options.packageName,
      version: "0.0.1",
      type: "module",
      sideEffects: false, // Enable aggressive tree-shaking
      description: options.description,
      exports,
      dependencies: options.libraryType === "provider"
        ? { "@custom-repo/infra-env": "*" }
        : undefined,
      peerDependencies: {
        effect: "*"
      }
    }

    // Write package.json
    const packageJsonPath = `${workspaceRoot}/${options.projectRoot}/package.json`
    yield* adapter.writeFile(
      packageJsonPath,
      JSON.stringify(packageJson, null, 2) + "\n"
    )
  })
}

/**
 * Generate TypeScript configuration files
 *
 * Creates:
 * - tsconfig.json (base configuration)
 * - tsconfig.lib.json (library build configuration)
 * - tsconfig.spec.json (test configuration)
 *
 * In Nx mode: Includes project references from dependency graph
 * In Effect mode: No project references (standalone)
 */
function generateTsConfigFiles(
  adapter: FileSystemAdapter,
  workspaceRoot: string,
  options: InfrastructureOptions
) {
  return Effect.gen(function*() {
    const filesGenerated: Array<string> = []

    // Project references (Nx mode only)
    // In effect mode, we don't have a dependency graph, so no references
    const references: Array<string> = []
    // TODO: In Nx mode, compute references from project graph
    // This requires access to Nx graph APIs which are only available in Tree context

    // Normalize offsetFromRoot (remove trailing slashes and collapse multiple slashes)
    const normalizedOffset = options.offsetFromRoot
      .replace(/\/+$/, "") // Remove one or more trailing slashes
      .replace(/\/+/g, "/") // Collapse multiple slashes to single slash

    // Generate tsconfig.json (base)
    const baseTsConfig = {
      extends: `${normalizedOffset}/tsconfig.base.json`,
      compilerOptions: {
        outDir: "./dist",
        rootDir: "./src",
        verbatimModuleSyntax: true // Preserve import/export for optimal tree-shaking
      },
      include: ["src/**/*.ts"],
      exclude: ["node_modules", "dist", "**/*.spec.ts"],
      references: references.length > 0
        ? references.map((ref) => ({ path: ref }))
        : undefined
    }

    yield* adapter.writeFile(
      `${workspaceRoot}/${options.projectRoot}/tsconfig.json`,
      JSON.stringify(baseTsConfig, null, 2) + "\n"
    )
    filesGenerated.push(`${options.projectRoot}/tsconfig.json`)

    // Generate tsconfig.lib.json (library build)
    const libTsConfig = {
      extends: "./tsconfig.json",
      compilerOptions: {
        outDir: `../../dist/${options.projectRoot}`,
        rootDir: "./src",
        composite: true,
        declaration: true,
        declarationMap: true,
        noEmit: false,
        tsBuildInfoFile: `../../dist/${options.projectRoot}/tsconfig.lib.tsbuildinfo`
      },
      include: ["src/**/*.ts"],
      exclude: ["src/**/*.spec.ts", "src/**/*.test.ts", "**/*.spec.ts"]
    }

    yield* adapter.writeFile(
      `${workspaceRoot}/${options.projectRoot}/tsconfig.lib.json`,
      JSON.stringify(libTsConfig, null, 2) + "\n"
    )
    filesGenerated.push(`${options.projectRoot}/tsconfig.lib.json`)

    // Generate tsconfig.spec.json (test)
    const specTsConfig = {
      extends: "./tsconfig.json",
      compilerOptions: {
        outDir: "./dist-test",
        types: ["vitest/globals", "node"]
      },
      include: [
        "src/**/*.test.ts",
        "src/**/*.spec.ts",
        "src/**/*.d.ts",
        "vitest.config.ts"
      ]
    }

    yield* adapter.writeFile(
      `${workspaceRoot}/${options.projectRoot}/tsconfig.spec.json`,
      JSON.stringify(specTsConfig, null, 2) + "\n"
    )
    filesGenerated.push(`${options.projectRoot}/tsconfig.spec.json`)

    return filesGenerated
  })
}

/**
 * Generate vitest configuration file
 *
 * Creates vitest.config.ts with:
 * - TypeScript path resolution
 * - Coverage configuration
 * - Test environment setup
 */
function generateVitestConfigFile(
  adapter: FileSystemAdapter,
  workspaceRoot: string,
  options: InfrastructureOptions
) {
  return Effect.gen(function*() {
    const vitestConfig = `import { defineConfig } from "vitest/config"

export default defineConfig({
  test: {
    globals: true,
    environment: "node",
    include: ["src/**/*.{test,spec}.ts"],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: [
        "node_modules/",
        "src/**/*.spec.ts",
        "src/**/*.test.ts"
      ]
    }
  }
})
`

    yield* adapter.writeFile(
      `${workspaceRoot}/${options.projectRoot}/vitest.config.ts`,
      vitestConfig
    )
  })
}

/**
 * Generate documentation files
 *
 * Creates:
 * - README.md (library-type specific template)
 * - CLAUDE.md (AI agent reference documentation)
 */
function generateDocumentationFiles(
  adapter: FileSystemAdapter,
  workspaceRoot: string,
  options: InfrastructureOptions
) {
  return Effect.gen(function*() {
    const filesGenerated: Array<string> = []

    // Generate README.md
    const readmeContent = generateReadmeContent(options)
    yield* adapter.writeFile(
      `${workspaceRoot}/${options.projectRoot}/README.md`,
      readmeContent
    )
    filesGenerated.push(`${options.projectRoot}/README.md`)

    // CLAUDE.md is generated by core generators, not infrastructure
    // (It's domain-specific, not infrastructure-specific)

    return filesGenerated
  })
}

/**
 * Generate source file scaffolds
 *
 * Creates basic index.ts barrel export.
 * Domain-specific files are generated by core generators.
 */
function generateSourceFileScaffolds(
  adapter: FileSystemAdapter,
  workspaceRoot: string,
  sourceRoot: string
) {
  return Effect.gen(function*() {
    const filesGenerated: Array<string> = []

    // Create src directory
    yield* adapter.makeDirectory(`${workspaceRoot}/${sourceRoot}`)

    // Note: index.ts and other domain files are generated by core generators
    // We don't generate them here to avoid duplication

    return filesGenerated
  })
}

/**
 * Create project configuration for Nx
 *
 * Builds the project.json structure with standard targets.
 * This is also used for registration via addProjectConfiguration().
 */
function createProjectConfiguration(
  options: InfrastructureOptions,
  sourceRoot: string
) {
  // Build additional entry points for client/server split
  const additionalEntryPoints: Array<string> = []
  if (options.includeClientServer) {
    additionalEntryPoints.push(`${sourceRoot}/server.ts`)
    additionalEntryPoints.push(`${sourceRoot}/client.ts`)
  }
  if (options.includeEdgeExports) {
    additionalEntryPoints.push(`${sourceRoot}/edge.ts`)
  }

  return {
    name: options.projectName,
    root: options.projectRoot,
    projectType: "library" as const,
    sourceRoot,
    tags: options.tags,
    targets: {
      build: {
        executor: "@nx/js:tsc",
        outputs: ["{options.outputPath}"],
        options: {
          outputPath: `dist/${options.projectRoot}`,
          tsConfig: `${options.projectRoot}/tsconfig.lib.json`,
          main: `${sourceRoot}/index.ts`,
          batch: true,
          ...(additionalEntryPoints.length > 0 && { additionalEntryPoints })
        }
      },
      test: {
        executor: "@nx/vite:test",
        outputs: ["{options.reportsDirectory}"],
        options: {
          passWithNoTests: true,
          reportsDirectory: `coverage/${options.projectRoot}`,
          config: `${options.projectRoot}/vitest.config.ts`
        }
      },
      lint: {
        executor: "@nx/eslint:lint",
        outputs: ["{options.outputFile}"],
        options: {
          lintFilePatterns: [`${sourceRoot}/**/*.ts`]
        }
      }
    }
  }
}

/**
 * Generate README content based on library type
 */
function generateReadmeContent(options: InfrastructureOptions) {
  const templates: Record<LibraryType, (opts: InfrastructureOptions) => string> = {
    contract: (opts) =>
      `# ${opts.packageName}

${opts.description}

## Overview

This contract library defines the core domain model and interfaces.

## Contents

- **Entities**: Domain entities with business logic
- **Events**: Domain events for event sourcing
- **Ports**: Service interfaces and contracts
- **Types**: Shared type definitions

## Usage

\`\`\`typescript
import { /* types */ } from '${opts.packageName}';
\`\`\`

## Development

\`\`\`bash
# Build
nx build ${opts.projectName}

# Test
nx test ${opts.projectName}
\`\`\`
`,

    "data-access": (opts) =>
      `# ${opts.packageName}

${opts.description}

## Overview

This data-access library provides repository patterns for data persistence.

## Contents

- **Repository**: Data access layer with CRUD operations
- **Queries**: Pre-built database queries
- **Validation**: Data validation schemas

## Usage

\`\`\`typescript
import { /* repository */ } from '${opts.packageName}';
\`\`\`

## Development

\`\`\`bash
# Build
nx build ${opts.projectName}

# Test
nx test ${opts.projectName}
\`\`\`
`,

    feature: (opts) =>
      `# ${opts.packageName}

${opts.description}

## Overview

This feature library implements business logic with Effect-based patterns.

## Installation

\`\`\`bash
pnpm install ${opts.packageName}
\`\`\`

## Contents

- **Server**: Server-side business logic and services
- **Client**: Client-side hooks and state management (if applicable)
- **Types**: Shared type definitions

## Usage

\`\`\`typescript
import { /* service */ } from '${opts.packageName}/server';
\`\`\`

## Development

\`\`\`bash
# Build
nx build ${opts.projectName}

# Test
nx test ${opts.projectName}
\`\`\`
`,

    infra: (opts) =>
      `# ${opts.packageName}

${opts.description}

## Overview

This infrastructure library provides service implementations.

## Contents

- **Service**: Core service implementation
- **Providers**: Service providers and adapters
- **Configuration**: Service configuration

## Usage

\`\`\`typescript
import { /* service */ } from '${opts.packageName}';
\`\`\`

## Development

\`\`\`bash
# Build
nx build ${opts.projectName}

# Test
nx test ${opts.projectName}
\`\`\`
`,

    provider: (opts) =>
      `# ${opts.packageName}

${opts.description}

## Overview

This provider library integrates with external services.

## Installation

\`\`\`bash
pnpm install ${opts.packageName}
\`\`\`

## Contents

- **Service**: External service client
- **Types**: API types and schemas
- **Validation**: Request/response validation

## Usage

\`\`\`typescript
import { /* service */ } from '${opts.packageName}';
\`\`\`

## Development

\`\`\`bash
# Build
nx build ${opts.projectName}

# Test
nx test ${opts.projectName}
\`\`\`
`,

    util: (opts) =>
      `# ${opts.packageName}

${opts.description}

## Overview

This utility library provides shared helper functions and utilities.

## Contents

- **Utilities**: Reusable helper functions
- **Types**: Shared type definitions
- **Constants**: Common constants

## Usage

\`\`\`typescript
import { /* utilities */ } from '${opts.packageName}';
\`\`\`

## Development

\`\`\`bash
# Build
nx build ${opts.projectName}

# Test
nx test ${opts.projectName}
\`\`\`
`
  }

  return templates[options.libraryType](options)
}
