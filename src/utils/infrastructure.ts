/**
 * Unified Infrastructure Generator
 *
 * Single source of truth for infrastructure file generation that works with
 * both Nx (via TreeAdapter) and CLI (via EffectFsAdapter).
 *
 * This generator creates:
 * - package.json (all modes)
 * - tsconfig.json, tsconfig.lib.json, tsconfig.spec.json (all modes)
 * - vitest.config.ts (all modes)
 * - README.md (all modes)
 *
 * Note: CLAUDE.md and project.json are generated by wrapper generators:
 * - CLAUDE.md: Generated by domain-specific core generators
 * - project.json: Written by addProjectConfiguration() in Nx mode
 *
 * Mode-specific behavior is determined by adapter.getMode():
 * - "nx": Returns config for Nx workspace registration via addProjectConfiguration()
 * -: Standalone library without Nx-specific configuration
 *
 * @module monorepo-library-generator/infrastructure
 */

import { Effect } from 'effect'
import {
  generatePackageJson,
  generateProjectJson,
  generateReadme,
  generateBaseTsConfig,
  generateLibTsConfig,
  generateSpecTsConfig,
  generateVitestConfig
} from '../generators/infrastructure/templates'
import type { LibraryType, PlatformType } from './build'
import type { FileSystemAdapter } from './filesystem'

/**
 * Unified Infrastructure Generation Options
 *
 * All options required for generating complete library infrastructure.
 * Pre-computed by wrapper generators (Nx or CLI).
 */
export interface InfrastructureOptions {
  /**
   * Project name (e.g., "feature-auth", "contract-user")
   */
  readonly projectName: string

  /**
   * Project root directory relative to workspace (e.g., "libs/feature/auth")
   */
  readonly projectRoot: string

  /**
   * Source root directory (e.g., "libs/feature/auth/src")
   */
  readonly sourceRoot?: string

  /**
   * Scoped package name (e.g., "@myorg/feature-auth")
   */
  readonly packageName: string

  /**
   * Human-readable description
   */
  readonly description: string

  /**
   * Library type (determines file structure and exports)
   */
  readonly libraryType: LibraryType

  /**
   * Target platform
   */
  readonly platform: PlatformType

  /**
   * Relative path from project root to workspace root (e.g., "../../..")
   */
  readonly offsetFromRoot: string

  /**
   * Project tags for Nx constraints
   */
  readonly tags: Array<string>

  /**
   * Generate client/server split exports
   */
  readonly includeClientServer?: boolean

  /**
   * Entity names for contract libraries (enables granular entity exports)
   */
  readonly entities?: ReadonlyArray<string>

  /**
   * Sub-module names for contract libraries (enables subpath exports)
   */
  readonly subModules?: ReadonlyArray<string>
}

/**
 * Infrastructure Generation Result
 *
 * Metadata returned after successful infrastructure generation.
 */
export interface InfrastructureGenerationResult {
  /**
   * Whether the project requires Nx workspace registration
   * (Only true in Nx mode)
   */
  readonly requiresNxRegistration: boolean

  /**
   * Project configuration for Nx registration
   * (Only present if requiresNxRegistration is true)
   */
  readonly projectConfig?: {
    readonly name: string
    readonly root: string
    readonly projectType: 'library'
    readonly sourceRoot: string
    readonly tags: Array<string>
    readonly targets: Record<string, unknown>
  }

  /**
   * Files generated during infrastructure phase
   */
  readonly filesGenerated: Array<string>
}

/**
 * Generate Library Infrastructure
 *
 * Main entry point for unified infrastructure generation.
 * Works with any FileSystemAdapter implementation.
 *
 * Behavior is mode-dependent:
 * - Nx mode: Generates infrastructure files, returns config for addProjectConfiguration()
 * - Effect mode: Generates infrastructure files (standalone library)
 *
 * @param adapter - FileSystemAdapter (TreeAdapter or EffectFsAdapter)
 * @param options - Infrastructure generation options
 * @returns Effect with generation result
 */
export function generateLibraryInfrastructure(
  adapter: FileSystemAdapter,
  options: InfrastructureOptions
) {
  return Effect.gen(function* () {
    const mode = adapter.getMode()
    const workspaceRoot = adapter.getWorkspaceRoot()
    const filesGenerated: Array<string> = []

    // Compute source root if not provided
    const sourceRoot = options.sourceRoot || `${options.projectRoot}/src`

    // 1. Generate package.json (all modes)
    yield* writePackageJson(adapter, workspaceRoot, options)
    filesGenerated.push(`${options.projectRoot}/package.json`)

    // 2. Generate TypeScript configuration files (all modes)
    const tsConfigFiles = yield* writeTsConfigFiles(adapter, workspaceRoot, options)
    for (const file of tsConfigFiles) {
      filesGenerated.push(file)
    }

    // 3. Generate vitest configuration (skip for contract libraries - types only)
    if (options.libraryType !== 'contract') {
      yield* writeVitestConfig(adapter, workspaceRoot, options)
      filesGenerated.push(`${options.projectRoot}/vitest.config.ts`)
    }

    // 4. Generate documentation files (all modes)
    const docFiles = yield* writeDocumentationFiles(adapter, workspaceRoot, options)
    for (const file of docFiles) {
      filesGenerated.push(file)
    }

    // 5. Generate source file scaffolds (all modes)
    const sourceFiles = yield* generateSourceFileScaffolds(adapter, workspaceRoot, sourceRoot)
    for (const file of sourceFiles) {
      filesGenerated.push(file)
    }

    // 6. Generate project configuration using template
    const projectConfig = generateProjectJson({
      projectName: options.projectName,
      projectRoot: options.projectRoot,
      sourceRoot,
      tags: options.tags,
      libraryType: options.libraryType,
      includeClientServer: options.includeClientServer
    })

    if (mode === 'nx') {
      // Nx mode: Return config for addProjectConfiguration() to handle via Nx devkit
      return {
        requiresNxRegistration: true,
        projectConfig: {
          name: projectConfig.name,
          root: options.projectRoot,
          projectType: projectConfig.projectType,
          sourceRoot: projectConfig.sourceRoot,
          tags: projectConfig.tags,
          targets: projectConfig.targets
        },
        filesGenerated
      }
    }

    // CLI/Effect mode: Write project.json directly
    const projectJsonPath = `${workspaceRoot}/${options.projectRoot}/project.json`
    yield* adapter.writeFile(projectJsonPath, `${JSON.stringify(projectConfig, null, 2)}\n`)
    filesGenerated.push(`${options.projectRoot}/project.json`)

    return {
      requiresNxRegistration: false,
      filesGenerated
    }
  })
}

/**
 * Write package.json file using template
 */
function writePackageJson(
  adapter: FileSystemAdapter,
  workspaceRoot: string,
  options: InfrastructureOptions
) {
  return Effect.gen(function* () {
    const packageJson = generatePackageJson({
      packageName: options.packageName,
      projectName: options.projectName,
      description: options.description,
      libraryType: options.libraryType,
      platform: options.platform,
      includeClientServer: options.includeClientServer,
      entities: options.entities,
      subModules: options.subModules
    })

    const packageJsonPath = `${workspaceRoot}/${options.projectRoot}/package.json`
    yield* adapter.writeFile(packageJsonPath, `${JSON.stringify(packageJson, null, 2)}\n`)
  })
}

/**
 * Write TypeScript configuration files using templates
 */
function writeTsConfigFiles(
  adapter: FileSystemAdapter,
  workspaceRoot: string,
  options: InfrastructureOptions
) {
  return Effect.gen(function* () {
    const filesGenerated: Array<string> = []

    // Generate tsconfig.json (base)
    const baseTsConfig = generateBaseTsConfig({
      offsetFromRoot: options.offsetFromRoot
    })

    yield* adapter.writeFile(
      `${workspaceRoot}/${options.projectRoot}/tsconfig.json`,
      `${JSON.stringify(baseTsConfig, null, 2)}\n`
    )
    filesGenerated.push(`${options.projectRoot}/tsconfig.json`)

    // Generate tsconfig.lib.json (library build)
    const libTsConfig = generateLibTsConfig({
      projectRoot: options.projectRoot
    })

    yield* adapter.writeFile(
      `${workspaceRoot}/${options.projectRoot}/tsconfig.lib.json`,
      `${JSON.stringify(libTsConfig, null, 2)}\n`
    )
    filesGenerated.push(`${options.projectRoot}/tsconfig.lib.json`)

    // Generate tsconfig.spec.json (test) - skip for contract libraries (types only)
    if (options.libraryType !== 'contract') {
      const specTsConfig = generateSpecTsConfig()

      yield* adapter.writeFile(
        `${workspaceRoot}/${options.projectRoot}/tsconfig.spec.json`,
        `${JSON.stringify(specTsConfig, null, 2)}\n`
      )
      filesGenerated.push(`${options.projectRoot}/tsconfig.spec.json`)
    }

    return filesGenerated
  })
}

/**
 * Write vitest configuration file using template
 */
function writeVitestConfig(
  adapter: FileSystemAdapter,
  workspaceRoot: string,
  options: InfrastructureOptions
) {
  return Effect.gen(function* () {
    const vitestConfig = generateVitestConfig()

    yield* adapter.writeFile(
      `${workspaceRoot}/${options.projectRoot}/vitest.config.ts`,
      vitestConfig
    )
  })
}

/**
 * Write documentation files using templates
 */
function writeDocumentationFiles(
  adapter: FileSystemAdapter,
  workspaceRoot: string,
  options: InfrastructureOptions
) {
  return Effect.gen(function* () {
    const filesGenerated: Array<string> = []

    // Generate README.md using template
    const readmeContent = generateReadme({
      packageName: options.packageName,
      projectName: options.projectName,
      description: options.description,
      libraryType: options.libraryType
    })

    yield* adapter.writeFile(`${workspaceRoot}/${options.projectRoot}/README.md`, readmeContent)
    filesGenerated.push(`${options.projectRoot}/README.md`)

    // CLAUDE.md is generated by core generators, not infrastructure
    // (It's domain-specific, not infrastructure-specific)

    return filesGenerated
  })
}

/**
 * Generate source file scaffolds
 *
 * Creates basic index.ts barrel export.
 * Domain-specific files are generated by core generators.
 */
function generateSourceFileScaffolds(
  adapter: FileSystemAdapter,
  workspaceRoot: string,
  sourceRoot: string
) {
  return Effect.gen(function* () {
    const filesGenerated: Array<string> = []

    // Create src directory
    yield* adapter.makeDirectory(`${workspaceRoot}/${sourceRoot}`)

    // Note: index.ts and other domain files are generated by core generators
    // We don't generate them here to avoid duplication

    return filesGenerated
  })
}
