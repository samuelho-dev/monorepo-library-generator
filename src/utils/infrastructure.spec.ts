/**
 * infrastructure.spec.ts
 *
 * Comprehensive integration tests for the unified infrastructure generator.
 * Tests mode-aware generation, complete file generation, and consistency across library types.
 */

import type { Tree } from "@nx/devkit"
import { createTreeWithEmptyWorkspace } from "@nx/devkit/testing"
import { Effect } from "effect"
import { generateLibraryInfrastructure } from "./infrastructure"
import { createTreeAdapter } from "./tree-adapter"

describe("infrastructure", () => {
  let tree: Tree

  beforeEach(() => {
    tree = createTreeWithEmptyWorkspace()
    // Add tsconfig.base.json for extends validation
    tree.write(
      "tsconfig.base.json",
      JSON.stringify({
        compilerOptions: {
          target: "ES2022",
          module: "ESNext"
        }
      })
    )
  })

  describe("Mode Detection", () => {
    it("should detect Nx mode from TreeAdapter", async () => {
      const adapter = createTreeAdapter(tree)

      const result = await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test contract library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract", "platform:universal"]
        })
      )

      expect(result.requiresNxRegistration).toBe(true)
      expect(result.projectConfig).toBeDefined()
    })
  })

  describe("Complete Infrastructure Generation", () => {
    it("should generate all 6 infrastructure files for contract library", async () => {
      const adapter = createTreeAdapter(tree)

      await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-product",
          projectRoot: "libs/contract/product",
          sourceRoot: "libs/contract/product/src",
          packageName: "@test/contract-product",
          description: "Product contracts",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract", "platform:universal"]
        })
      )

      // Verify all 6 infrastructure files exist (CLAUDE.md is generated by core generators)
      expect(tree.exists("libs/contract/product/package.json")).toBe(true)
      expect(tree.exists("libs/contract/product/tsconfig.json")).toBe(true)
      expect(tree.exists("libs/contract/product/tsconfig.lib.json")).toBe(true)
      expect(tree.exists("libs/contract/product/tsconfig.spec.json")).toBe(true)
      expect(tree.exists("libs/contract/product/vitest.config.ts")).toBe(true)
      expect(tree.exists("libs/contract/product/README.md")).toBe(true)
    })

    it("should generate all 6 infrastructure files for data-access library", async () => {
      const adapter = createTreeAdapter(tree)

      await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "data-access-user",
          projectRoot: "libs/data-access/user",
          sourceRoot: "libs/data-access/user/src",
          packageName: "@test/data-access-user",
          description: "User data access",
          libraryType: "data-access",
          platform: "node",
          offsetFromRoot: "../../../",
          tags: ["type:data-access", "platform:node"]
        })
      )

      // Verify all 6 infrastructure files exist (CLAUDE.md is generated by core generators)
      expect(tree.exists("libs/data-access/user/package.json")).toBe(true)
      expect(tree.exists("libs/data-access/user/tsconfig.json")).toBe(true)
      expect(tree.exists("libs/data-access/user/tsconfig.lib.json")).toBe(true)
      expect(tree.exists("libs/data-access/user/tsconfig.spec.json")).toBe(true)
      expect(tree.exists("libs/data-access/user/vitest.config.ts")).toBe(true)
      expect(tree.exists("libs/data-access/user/README.md")).toBe(true)
    })

    it("should generate all 6 infrastructure files for feature library", async () => {
      const adapter = createTreeAdapter(tree)

      await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "feature-auth",
          projectRoot: "libs/feature/auth",
          sourceRoot: "libs/feature/auth/src",
          packageName: "@test/feature-auth",
          description: "Auth feature",
          libraryType: "feature",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:feature", "platform:universal"],
          includeClientServer: true
        })
      )

      // Verify all 6 infrastructure files exist (CLAUDE.md is generated by core generators)
      expect(tree.exists("libs/feature/auth/package.json")).toBe(true)
      expect(tree.exists("libs/feature/auth/tsconfig.json")).toBe(true)
      expect(tree.exists("libs/feature/auth/tsconfig.lib.json")).toBe(true)
      expect(tree.exists("libs/feature/auth/tsconfig.spec.json")).toBe(true)
      expect(tree.exists("libs/feature/auth/vitest.config.ts")).toBe(true)
      expect(tree.exists("libs/feature/auth/README.md")).toBe(true)
    })
  })

  describe("TypeScript Configuration", () => {
    it("should generate correct tsconfig.json extends path", async () => {
      const adapter = createTreeAdapter(tree)

      await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })
      )

      const tsconfig = JSON.parse(tree.read("libs/contract/test/tsconfig.json", "utf-8") || "{}")
      expect(tsconfig.extends).toBe("../../../tsconfig.base.json")
      expect(tsconfig.extends).not.toContain("//") // No double-slash bug
    })

    it("should generate tsconfig.lib.json with correct configuration", async () => {
      const adapter = createTreeAdapter(tree)

      await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })
      )

      const tsconfigLib = JSON.parse(tree.read("libs/contract/test/tsconfig.lib.json", "utf-8") || "{}")
      expect(tsconfigLib.extends).toBe("./tsconfig.json")
      expect(tsconfigLib.compilerOptions.outDir).toContain("dist/libs/contract/test")
      expect(tsconfigLib.compilerOptions.declaration).toBe(true)
      expect(tsconfigLib.exclude).toContain("**/*.spec.ts")
    })

    it("should generate tsconfig.spec.json with vitest globals", async () => {
      const adapter = createTreeAdapter(tree)

      await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })
      )

      const tsconfigSpec = JSON.parse(tree.read("libs/contract/test/tsconfig.spec.json", "utf-8") || "{}")
      expect(tsconfigSpec.extends).toBe("./tsconfig.json")
      expect(tsconfigSpec.compilerOptions.types).toContain("vitest/globals")
      expect(tsconfigSpec.include).toContain("src/**/*.spec.ts")
    })
  })

  describe("Package.json Generation", () => {
    it("should generate package.json with granular exports for contract", async () => {
      const adapter = createTreeAdapter(tree)

      await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-product",
          projectRoot: "libs/contract/product",
          sourceRoot: "libs/contract/product/src",
          packageName: "@test/contract-product",
          description: "Product contracts",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"],
          entities: ["Product", "Order"] // Enables entity exports
        })
      )

      const packageJson = JSON.parse(tree.read("libs/contract/product/package.json", "utf-8") || "{}")

      // Check basic fields
      expect(packageJson.name).toBe("@test/contract-product")
      expect(packageJson.type).toBe("module")
      expect(packageJson.sideEffects).toBe(false)

      // Check granular exports
      expect(packageJson.exports["."]).toBeDefined()
      expect(packageJson.exports["./types"]).toBeDefined()
      expect(packageJson.exports["./entities"]).toBeDefined()
      expect(packageJson.exports["./errors"]).toBeDefined()
      expect(packageJson.exports["./ports"]).toBeDefined()
    })

    it("should generate package.json with client/server exports for feature", async () => {
      const adapter = createTreeAdapter(tree)

      await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "feature-auth",
          projectRoot: "libs/feature/auth",
          sourceRoot: "libs/feature/auth/src",
          packageName: "@test/feature-auth",
          description: "Auth feature",
          libraryType: "feature",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:feature"],
          includeClientServer: true
        })
      )

      const packageJson = JSON.parse(tree.read("libs/feature/auth/package.json", "utf-8") || "{}")

      // Check platform-specific exports
      expect(packageJson.exports["./server"]).toBeDefined()
      expect(packageJson.exports["./client"]).toBeDefined()
      expect(packageJson.exports["./types"]).toBeDefined()
    })
  })

  describe("Vitest Configuration", () => {
    it("should generate vitest.config.ts with correct settings", async () => {
      const adapter = createTreeAdapter(tree)

      await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })
      )

      const vitestConfig = tree.read("libs/contract/test/vitest.config.ts", "utf-8")

      expect(vitestConfig).toContain("defineConfig")
      expect(vitestConfig).toContain("globals: true")
      expect(vitestConfig).toContain("environment: \"node\"")
      expect(vitestConfig).toContain("src/**/*.{test,spec}.ts")
    })
  })

  describe("Documentation Generation", () => {
    it("should generate library-specific README for contract", async () => {
      const adapter = createTreeAdapter(tree)

      await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-product",
          projectRoot: "libs/contract/product",
          sourceRoot: "libs/contract/product/src",
          packageName: "@test/contract-product",
          description: "Product contracts",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })
      )

      const readme = tree.read("libs/contract/product/README.md", "utf-8")

      expect(readme).toContain("@test/contract-product")
      expect(readme).toContain("Product contracts")
      expect(readme).toContain("contract library")
      expect(readme).toContain("Entities")
      expect(readme).toContain("Events")
      expect(readme).toContain("Ports")
    })
  })

  describe("Nx Project Configuration", () => {
    it("should return project configuration for Nx registration", async () => {
      const adapter = createTreeAdapter(tree)

      const result = await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract", "platform:universal"]
        })
      )

      expect(result.requiresNxRegistration).toBe(true)
      expect(result.projectConfig).toBeDefined()
      expect(result.projectConfig?.name).toBe("contract-test")
      expect(result.projectConfig?.root).toBe("libs/contract/test")
      expect(result.projectConfig?.sourceRoot).toBe("libs/contract/test/src")
      expect(result.projectConfig?.tags).toEqual(["type:contract", "platform:universal"])
    })

    it("should include build and test targets in project configuration", async () => {
      const adapter = createTreeAdapter(tree)

      const result = await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })
      )

      const targets = result.projectConfig?.targets
      expect(targets).toBeDefined()
      expect(targets?.build).toBeDefined()
      expect(targets?.test).toBeDefined()
      expect(targets?.lint).toBeDefined()
    })
  })

  describe("Regression Tests", () => {
    it("should handle offsetFromRoot with trailing slash correctly", async () => {
      const adapter = createTreeAdapter(tree)

      await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../..//", // With trailing slash
          tags: ["type:contract"]
        })
      )

      const tsconfig = JSON.parse(tree.read("libs/contract/test/tsconfig.json", "utf-8") || "{}")
      // Should normalize to remove double slash
      expect(tsconfig.extends).toBe("../../../tsconfig.base.json")
      expect(tsconfig.extends).not.toContain("////")
    })

    it("should handle empty entities array for contract", async () => {
      const adapter = createTreeAdapter(tree)

      const result = await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"],
          entities: []
        })
      )

      expect(result.filesGenerated).toBeDefined()
      expect(result.filesGenerated.length).toBeGreaterThan(0)
    })
  })

  describe("File Generation Count", () => {
    it("should report correct number of files generated", async () => {
      const adapter = createTreeAdapter(tree)

      const result = await Effect.runPromise(
        generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })
      )

      // Should generate at least 6 infrastructure files (might generate more like project.json in Nx mode)
      expect(result.filesGenerated.length).toBeGreaterThanOrEqual(6)
      expect(result.filesGenerated).toContain("libs/contract/test/package.json")
      expect(result.filesGenerated).toContain("libs/contract/test/tsconfig.json")
      expect(result.filesGenerated).toContain("libs/contract/test/vitest.config.ts")
    })
  })
})
