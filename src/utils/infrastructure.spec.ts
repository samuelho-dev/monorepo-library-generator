/**
 * infrastructure.spec.ts
 *
 * Comprehensive integration tests for the unified infrastructure generator.
 * Tests mode-aware generation, complete file generation, and consistency across library types.
 */

import { beforeEach, describe, expect, it } from "@effect/vitest"
import type { Tree } from "@nx/devkit"
import { createTreeWithEmptyWorkspace } from "@nx/devkit/testing"
import { Effect } from "effect"
import { generateLibraryInfrastructure } from "./infrastructure"
import { createTreeAdapter } from "./tree-adapter"

describe("infrastructure", () => {
  let tree: Tree

  beforeEach(() => {
    tree = createTreeWithEmptyWorkspace()
    // Add tsconfig.base.json for extends validation
    tree.write(
      "tsconfig.base.json",
      JSON.stringify({
        compilerOptions: {
          target: "ES2022",
          module: "ESNext"
        }
      })
    )
  })

  describe("Mode Detection", () => {
    it.effect("should detect Nx mode from TreeAdapter", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        const result = yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test contract library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract", "platform:universal"]
        })

        expect(result.requiresNxRegistration).toBe(true)
        expect(result.projectConfig).toBeDefined()
      }))
  })

  describe("Complete Infrastructure Generation", () => {
    it.effect("should generate all 6 infrastructure files for contract library", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-product",
          projectRoot: "libs/contract/product",
          sourceRoot: "libs/contract/product/src",
          packageName: "@test/contract-product",
          description: "Product contracts",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract", "platform:universal"]
        })

        // Verify all 6 infrastructure files exist (CLAUDE.md is generated by core generators)
        expect(tree.exists("libs/contract/product/package.json")).toBe(true)
        expect(tree.exists("libs/contract/product/tsconfig.json")).toBe(true)
        expect(tree.exists("libs/contract/product/tsconfig.lib.json")).toBe(true)
        expect(tree.exists("libs/contract/product/tsconfig.spec.json")).toBe(true)
        expect(tree.exists("libs/contract/product/vitest.config.ts")).toBe(true)
        expect(tree.exists("libs/contract/product/README.md")).toBe(true)
      }))

    it.effect("should generate all 6 infrastructure files for data-access library", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        yield* generateLibraryInfrastructure(adapter, {
          projectName: "data-access-user",
          projectRoot: "libs/data-access/user",
          sourceRoot: "libs/data-access/user/src",
          packageName: "@test/data-access-user",
          description: "User data access",
          libraryType: "data-access",
          platform: "node",
          offsetFromRoot: "../../../",
          tags: ["type:data-access", "platform:node"]
        })

        // Verify all 6 infrastructure files exist (CLAUDE.md is generated by core generators)
        expect(tree.exists("libs/data-access/user/package.json")).toBe(true)
        expect(tree.exists("libs/data-access/user/tsconfig.json")).toBe(true)
        expect(tree.exists("libs/data-access/user/tsconfig.lib.json")).toBe(true)
        expect(tree.exists("libs/data-access/user/tsconfig.spec.json")).toBe(true)
        expect(tree.exists("libs/data-access/user/vitest.config.ts")).toBe(true)
        expect(tree.exists("libs/data-access/user/README.md")).toBe(true)
      }))

    it.effect("should generate all 6 infrastructure files for feature library", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        yield* generateLibraryInfrastructure(adapter, {
          projectName: "feature-auth",
          projectRoot: "libs/feature/auth",
          sourceRoot: "libs/feature/auth/src",
          packageName: "@test/feature-auth",
          description: "Auth feature",
          libraryType: "feature",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:feature", "platform:universal"],
          includeClientServer: true
        })

        // Verify all 6 infrastructure files exist (CLAUDE.md is generated by core generators)
        expect(tree.exists("libs/feature/auth/package.json")).toBe(true)
        expect(tree.exists("libs/feature/auth/tsconfig.json")).toBe(true)
        expect(tree.exists("libs/feature/auth/tsconfig.lib.json")).toBe(true)
        expect(tree.exists("libs/feature/auth/tsconfig.spec.json")).toBe(true)
        expect(tree.exists("libs/feature/auth/vitest.config.ts")).toBe(true)
        expect(tree.exists("libs/feature/auth/README.md")).toBe(true)
      }))
  })

  describe("TypeScript Configuration", () => {
    it.effect("should generate correct tsconfig.json extends path", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })

        const tsconfig = JSON.parse(tree.read("libs/contract/test/tsconfig.json", "utf-8") || "{}")
        expect(tsconfig.extends).toBe("../../../tsconfig.base.json")
        expect(tsconfig.extends).not.toContain("//") // No double-slash bug
      }))

    it.effect("should generate tsconfig.lib.json with correct configuration", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })

        const tsconfigLib = JSON.parse(tree.read("libs/contract/test/tsconfig.lib.json", "utf-8") || "{}")
        expect(tsconfigLib.extends).toBe("./tsconfig.json")
        expect(tsconfigLib.compilerOptions.outDir).toContain("dist/libs/contract/test")
        expect(tsconfigLib.compilerOptions.declaration).toBe(true)
        expect(tsconfigLib.exclude).toContain("**/*.spec.ts")
      }))

    it.effect("should generate tsconfig.spec.json with vitest globals", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })

        const tsconfigSpec = JSON.parse(tree.read("libs/contract/test/tsconfig.spec.json", "utf-8") || "{}")
        expect(tsconfigSpec.extends).toBe("./tsconfig.json")
        expect(tsconfigSpec.compilerOptions.types).toContain("vitest/globals")
        expect(tsconfigSpec.include).toContain("src/**/*.spec.ts")
      }))
  })

  describe("Package.json Generation", () => {
    it.effect("should generate package.json with granular exports for contract", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-product",
          projectRoot: "libs/contract/product",
          sourceRoot: "libs/contract/product/src",
          packageName: "@test/contract-product",
          description: "Product contracts",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"],
          entities: ["Product", "Order"] // Enables entity exports
        })

        const packageJson = JSON.parse(tree.read("libs/contract/product/package.json", "utf-8") || "{}")

        // Check basic fields
        expect(packageJson.name).toBe("@test/contract-product")
        expect(packageJson.type).toBe("module")
        expect(packageJson.sideEffects).toBe(false)

        // Check granular exports
        expect(packageJson.exports["."]).toBeDefined()
        expect(packageJson.exports["./types"]).toBeDefined()
        expect(packageJson.exports["./entities"]).toBeDefined()
        expect(packageJson.exports["./errors"]).toBeDefined()
        expect(packageJson.exports["./ports"]).toBeDefined()
      }))

    it.effect("should generate package.json with client/server exports for feature", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        yield* generateLibraryInfrastructure(adapter, {
          projectName: "feature-auth",
          projectRoot: "libs/feature/auth",
          sourceRoot: "libs/feature/auth/src",
          packageName: "@test/feature-auth",
          description: "Auth feature",
          libraryType: "feature",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:feature"],
          includeClientServer: true
        })

        const packageJson = JSON.parse(tree.read("libs/feature/auth/package.json", "utf-8") || "{}")

        // Platform-specific exports removed - only functional exports
        expect(packageJson.exports["."]).toBeDefined()
        expect(packageJson.exports["./types"]).toBeDefined()
      }))
  })

  describe("Vitest Configuration", () => {
    it.effect("should generate vitest.config.ts with correct settings", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })

        const vitestConfig = tree.read("libs/contract/test/vitest.config.ts", "utf-8")

        expect(vitestConfig).toContain("defineConfig")
        expect(vitestConfig).toContain("globals: true")
        expect(vitestConfig).toContain("environment: \"node\"")
        expect(vitestConfig).toContain("src/**/*.{test,spec}.ts")
      }))
  })

  describe("Documentation Generation", () => {
    it.effect("should generate library-specific README for contract", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-product",
          projectRoot: "libs/contract/product",
          sourceRoot: "libs/contract/product/src",
          packageName: "@test/contract-product",
          description: "Product contracts",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })

        const readme = tree.read("libs/contract/product/README.md", "utf-8")

        expect(readme).toContain("@test/contract-product")
        expect(readme).toContain("Product contracts")
        expect(readme).toContain("contract library")
        expect(readme).toContain("Entities")
        expect(readme).toContain("Events")
        expect(readme).toContain("Ports")
      }))
  })

  describe("Nx Project Configuration", () => {
    it.effect("should return project configuration for Nx registration", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        const result = yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract", "platform:universal"]
        })

        expect(result.requiresNxRegistration).toBe(true)
        expect(result.projectConfig).toBeDefined()
        expect(result.projectConfig?.name).toBe("contract-test")
        expect(result.projectConfig?.root).toBe("libs/contract/test")
        expect(result.projectConfig?.sourceRoot).toBe("libs/contract/test/src")
        expect(result.projectConfig?.tags).toEqual(["type:contract", "platform:universal"])
      }))

    it.effect("should include build and test targets in project configuration", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        const result = yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })

        const targets = result.projectConfig?.targets
        expect(targets).toBeDefined()
        expect(targets?.build).toBeDefined()
        expect(targets?.test).toBeDefined()
        expect(targets?.lint).toBeDefined()
      }))
  })

  describe("Regression Tests", () => {
    it.effect("should handle offsetFromRoot with trailing slash correctly", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../..//", // With trailing slash
          tags: ["type:contract"]
        })

        const tsconfig = JSON.parse(tree.read("libs/contract/test/tsconfig.json", "utf-8") || "{}")
        // Should normalize to remove double slash
        expect(tsconfig.extends).toBe("../../../tsconfig.base.json")
        expect(tsconfig.extends).not.toContain("////")
      }))

    it.effect("should handle empty entities array for contract", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        const result = yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"],
          entities: []
        })

        expect(result.filesGenerated).toBeDefined()
        expect(result.filesGenerated.length).toBeGreaterThan(0)
      }))
  })

  describe("File Generation Count", () => {
    it.effect("should report correct number of files generated", () =>
      Effect.gen(function*() {
        const adapter = createTreeAdapter(tree)

        const result = yield* generateLibraryInfrastructure(adapter, {
          projectName: "contract-test",
          projectRoot: "libs/contract/test",
          sourceRoot: "libs/contract/test/src",
          packageName: "@test/contract-test",
          description: "Test library",
          libraryType: "contract",
          platform: "universal",
          offsetFromRoot: "../../../",
          tags: ["type:contract"]
        })

        // Should generate at least 6 infrastructure files (might generate more like project.json in Nx mode)
        expect(result.filesGenerated.length).toBeGreaterThanOrEqual(6)
        expect(result.filesGenerated).toContain("libs/contract/test/package.json")
        expect(result.filesGenerated).toContain("libs/contract/test/tsconfig.json")
        expect(result.filesGenerated).toContain("libs/contract/test/vitest.config.ts")
      }))
  })
})
