/**
 * Workspace Tags Utility
 *
 * Scans workspace project.json files to discover existing tags.
 * Filters out auto-generated tags (type:*, scope:*) to show only custom tags.
 *
 * @module monorepo-library-generator/utils/workspace-tags
 */

import * as fs from 'node:fs'
import * as path from 'node:path'
import { Effect } from 'effect'

/**
 * Result of scanning workspace for tags
 */
export interface WorkspaceTagsResult {
  readonly allTags: ReadonlyArray<string>
  readonly customTags: ReadonlyArray<string>
}

/**
 * Check if a tag is auto-generated (type:* or scope:*)
 */
export function isAutoGeneratedTag(tag: string) {
  return tag.startsWith('type:') || tag.startsWith('scope:')
}

/**
 * Normalize a tag for comparison (lowercase, trimmed)
 */
export function normalizeTag(tag: string) {
  return tag.trim().toLowerCase()
}

/**
 * Recursively find all project.json files in a directory
 */
function findProjectJsonFiles(dir: string) {
  if (!fs.existsSync(dir)) return []

  const files: Array<string> = []

  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name)

    if (entry.isDirectory()) {
      // Skip node_modules and hidden directories
      if (entry.name !== 'node_modules' && !entry.name.startsWith('.')) {
        for (const file of findProjectJsonFiles(fullPath)) {
          files.push(file)
        }
      }
    } else if (entry.name === 'project.json') {
      files.push(fullPath)
    }
  }

  return files
}

/**
 * Scan workspace for all tags from project.json files
 *
 * @param workspaceRoot - The root directory of the workspace
 * @returns Effect containing all tags and filtered custom tags
 */
export function scanWorkspaceTags(workspaceRoot: string) {
  return Effect.sync(() => {
    const libsDir = path.join(workspaceRoot, 'libs')
    const allTags = new Set<string>()

    // Find and process all project.json files
    for (const file of findProjectJsonFiles(libsDir)) {
      try {
        const content = JSON.parse(fs.readFileSync(file, 'utf-8'))

        if (Array.isArray(content.tags)) {
          for (const tag of content.tags) {
            if (typeof tag === 'string' && tag.trim()) {
              allTags.add(tag.trim())
            }
          }
        }
      } catch {
        // Skip files that can't be parsed
      }
    }

    const tagsArray = Array.from(allTags).sort()

    return {
      allTags: tagsArray,
      customTags: tagsArray.filter((tag) => !isAutoGeneratedTag(tag))
    }
  })
}

/**
 * Check if a tag already exists (case-insensitive comparison)
 */
export function tagExists(tag: string, existingTags: ReadonlyArray<string>) {
  const normalized = normalizeTag(tag)
  return existingTags.some((t) => normalizeTag(t) === normalized)
}
