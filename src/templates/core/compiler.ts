/**
 * Template Compiler Service
 *
 * Effect-idiomatic service for compiling template definitions to TypeScript.
 * Uses Context.Tag pattern with Layer-based dependency injection.
 *
 * @module monorepo-library-generator/templates/core/compiler
 */

import { Context, Data, Effect, Layer, Metric } from "effect"
import { Project, type SourceFile } from "ts-morph"
import { taggedTemplateDuration, templateCompilations } from "../../infrastructure/metrics"
import {
  addConstExport,
  addContextTagClass,
  addEffectImports,
  addImport,
  addSchemaDefinition,
  addSectionComment,
  addTaggedErrorClass,
  addTypeImport
} from "../ast/effect-builders"
import { interpolateDeep, interpolateSync } from "./resolver"
import type {
  ClassConfig,
  ConditionalContent,
  ConstantConfig,
  ContentDefinition,
  ContextTagConfig,
  ImportDefinition,
  InterfaceConfig,
  SchemaConfig,
  SectionDefinition,
  TaggedErrorConfig,
  TemplateContext,
  TemplateDefinition
} from "./types"

// ============================================================================
// Error Types
// ============================================================================

/**
 * Template Compilation Error
 */
export class CompilationError extends Data.TaggedError("CompilationError")<{
  readonly templateId: string
  readonly message: string
  readonly diagnostics?: ReadonlyArray<{ line: number; column: number; message: string }>
}> {}

// ============================================================================
// Service Interface
// ============================================================================

/**
 * Template Compiler Service Interface
 *
 * All methods return Effect<A, E, never> - no dependencies in R.
 * Dependencies are captured at Layer construction time.
 */
interface TemplateCompilerImpl {
  /**
   * Compile a template definition to TypeScript source
   */
  readonly compile: (
    template: TemplateDefinition,
    context: TemplateContext
  ) => Effect.Effect<string, CompilationError, never>

  /**
   * Get compilation diagnostics for source code
   */
  readonly getDiagnostics: (
    code: string
  ) => Effect.Effect<ReadonlyArray<{ line: number; column: number; message: string }>, never, never>

  /**
   * Reset the compiler (clear all files)
   */
  readonly reset: () => Effect.Effect<void, never, never>
}

// ============================================================================
// Service Tag
// ============================================================================

/**
 * Template Compiler Service Tag
 *
 * Usage:
 * ```typescript
 * const program = Effect.gen(function* () {
 *   const compiler = yield* TemplateCompiler
 *   const result = yield* compiler.compile(template, context)
 *   return result
 * })
 *
 * // Provide the layer
 * program.pipe(Effect.provide(TemplateCompiler.Live))
 * ```
 */
export class TemplateCompiler extends Context.Tag("TemplateCompiler")<
  TemplateCompiler,
  TemplateCompilerImpl
>() {
  /**
   * Live implementation with ts-morph Project
   */
  static readonly Live: Layer.Layer<TemplateCompiler> = Layer.sync(TemplateCompiler, () => {
    // Capture Project instance at layer construction
    const project = new Project({
      useInMemoryFileSystem: true,
      compilerOptions: {
        strict: true,
        target: 99, // ESNext
        module: 99, // ESNext
        moduleResolution: 100, // Bundler
        declaration: true,
        skipLibCheck: true
      }
    })

    // Helper functions (pure, no this references)
    const addFileHeader = (sourceFile: SourceFile, title: string, description: string) => {
      sourceFile.addStatements(`/**
 * ${title}
 *
 * ${description}
 *
 * @generated This file was generated by monorepo-library-generator
 */
`)
    }

    const addInterface = (sourceFile: SourceFile, config: InterfaceConfig) => {
      const properties = config.properties.map((p) => ({
        name: p.name,
        type: p.type,
        isReadonly: p.readonly,
        hasQuestionToken: p.optional
      }))

      const methods = config.methods?.map((m) => ({
        name: m.name,
        parameters: m.params.map((p) => ({
          name: p.name,
          type: p.type,
          hasQuestionToken: p.optional
        })),
        returnType: m.returnType
      })) ?? []

      const interfaceDecl = sourceFile.addInterface({
        name: config.name,
        isExported: config.isExported ?? true,
        extends: config.extends,
        properties,
        methods
      })

      if (config.jsdoc) {
        interfaceDecl.addJsDoc({ description: config.jsdoc })
      }
    }

    const addClass = (sourceFile: SourceFile, config: ClassConfig) => {
      const properties = config.properties?.map((p) => ({
        name: p.name,
        type: p.type,
        isReadonly: p.readonly,
        hasQuestionToken: p.optional
      })) ?? []

      const methods = config.methods?.map((m) => ({
        name: m.name,
        isStatic: m.isStatic,
        isAsync: m.isAsync,
        parameters: m.params.map((p) => ({
          name: p.name,
          type: p.type,
          hasQuestionToken: p.optional
        })),
        returnType: m.returnType,
        statements: m.body
      })) ?? []

      const statics = config.statics?.map((s) => ({
        name: s.name,
        isStatic: true,
        type: s.type,
        initializer: s.value
      })) ?? []

      const classDecl = sourceFile.addClass({
        name: config.name,
        isExported: config.isExported ?? true,
        extends: config.extends,
        implements: config.implements,
        properties: [...properties, ...statics],
        methods
      })

      if (config.jsdoc) {
        classDecl.addJsDoc({ description: config.jsdoc })
      }
    }

    // Type-safe interpolation functions for each config type
    const interpolateContextTagConfig = (config: ContextTagConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    const interpolateTaggedErrorConfig = (config: TaggedErrorConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    const interpolateSchemaConfig = (config: SchemaConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    const interpolateInterfaceConfig = (config: InterfaceConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    const interpolateClassConfig = (config: ClassConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    const interpolateConstantConfig = (config: ConstantConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    // Content processor (functional, captures helpers via closure)
    const processContent = (
      sourceFile: SourceFile,
      content: ContentDefinition,
      context: TemplateContext
    ) =>
      Effect.gen(function*() {
        switch (content.type) {
          case "raw": {
            const value = interpolateSync(content.value, context)
            sourceFile.insertText(sourceFile.getEnd(), `\n${value}\n`)
            break
          }

          case "contextTag": {
            const config = yield* interpolateContextTagConfig(content.config, context)
            addContextTagClass(sourceFile, config)
            break
          }

          case "taggedError": {
            const config = yield* interpolateTaggedErrorConfig(content.config, context)
            addTaggedErrorClass(sourceFile, config)
            break
          }

          case "schema": {
            const config = yield* interpolateSchemaConfig(content.config, context)
            addSchemaDefinition(sourceFile, config)
            break
          }

          case "interface": {
            const config = yield* interpolateInterfaceConfig(content.config, context)
            addInterface(sourceFile, config)
            break
          }

          case "class": {
            const config = yield* interpolateClassConfig(content.config, context)
            addClass(sourceFile, config)
            break
          }

          case "constant": {
            const config = yield* interpolateConstantConfig(content.config, context)
            addConstExport(sourceFile, config.name, config.type, config.value, config.jsdoc)
            break
          }

          case "rpcDefinition":
          case "fragment":
            // TODO: Implement in Phase 3
            break
        }
      })

    // Section processor
    const processSection = (
      sourceFile: SourceFile,
      section: SectionDefinition,
      context: TemplateContext
    ) =>
      Effect.gen(function*() {
        if (section.condition && !context[section.condition]) {
          return
        }

        if (section.title) {
          const title = interpolateSync(section.title, context)
          addSectionComment(sourceFile, title)
        }

        const contents = Array.isArray(section.content) ? section.content : [section.content]
        for (const content of contents) {
          yield* processContent(sourceFile, content, context)
        }
      })

    // Import processor
    const processImports = (
      sourceFile: SourceFile,
      imports: ReadonlyArray<ImportDefinition>,
      context: TemplateContext
    ) =>
      Effect.sync(() => {
        for (const imp of imports) {
          if (imp.condition && !context[imp.condition]) {
            continue
          }

          const items = imp.items.map((item) => interpolateSync(item, context))
          const from = interpolateSync(imp.from, context)

          if (imp.isTypeOnly) {
            addTypeImport(sourceFile, from, items)
          } else if (from === "effect") {
            addEffectImports(sourceFile, items)
          } else {
            addImport(sourceFile, from, items)
          }
        }
      })

    // Conditional content processor
    const processConditionalContent = (
      sourceFile: SourceFile,
      content: ConditionalContent,
      context: TemplateContext
    ) =>
      Effect.gen(function*() {
        if (content.imports) {
          yield* processImports(sourceFile, content.imports, context)
        }

        for (const section of content.sections) {
          yield* processSection(sourceFile, section, context)
        }
      })

    // Return the service implementation
    return {
      compile: (template, context) =>
        Effect.gen(function*() {
          const startTime = Date.now()

          yield* templateCompilations.pipe(
            Metric.tagged("template_id", template.id),
            Metric.increment
          )

          const sourceFile = project.createSourceFile(`${template.id.replace("/", "-")}.ts`, "", {
            overwrite: true
          })

          const title = interpolateSync(template.meta.title, context)
          const description = interpolateSync(template.meta.description, context)
          addFileHeader(sourceFile, title, description)

          yield* processImports(sourceFile, template.imports, context)

          for (const section of template.sections) {
            yield* processSection(sourceFile, section, context)
          }

          if (template.conditionals) {
            for (const [conditionKey, content] of Object.entries(template.conditionals)) {
              if (context[conditionKey]) {
                yield* processConditionalContent(sourceFile, content, context)
              }
            }
          }

          sourceFile.formatText({
            indentSize: 2,
            convertTabsToSpaces: true
          })

          const result = sourceFile.getFullText()

          const duration = Date.now() - startTime
          yield* taggedTemplateDuration(template.id).pipe(Metric.update(duration))

          return result
        }).pipe(
          Effect.catchAll((error) =>
            Effect.fail(
              new CompilationError({
                templateId: template.id,
                message: error instanceof Error ? error.message : String(error)
              })
            )
          ),
          Effect.catchAllDefect((defect) =>
            Effect.fail(
              new CompilationError({
                templateId: template.id,
                message: defect instanceof Error ? defect.message : String(defect)
              })
            )
          ),
          Effect.withSpan(`template.compile.${template.id}`, {
            attributes: {
              "template.id": template.id,
              "context.className": context.className
            }
          })
        ),

      getDiagnostics: (code) =>
        Effect.sync(() => {
          const sourceFile = project.createSourceFile("__check__.ts", code, { overwrite: true })
          const diagnostics = sourceFile.getPreEmitDiagnostics()

          return diagnostics.map((d) => {
            const start = d.getStart()
            const lineAndCol = start !== undefined ? sourceFile.getLineAndColumnAtPos(start) : { line: 0, column: 0 }

            return {
              line: lineAndCol.line,
              column: lineAndCol.column,
              message: d.getMessageText().toString()
            }
          })
        }),

      reset: () =>
        Effect.sync(() => {
          for (const sourceFile of project.getSourceFiles()) {
            project.removeSourceFile(sourceFile)
          }
        })
    }
  })

  /**
   * Test implementation with isolated state
   *
   * Creates a fresh Project instance per test to prevent test pollution.
   */
  static readonly Test: Layer.Layer<TemplateCompiler> = Layer.sync(TemplateCompiler, () => {
    // Fresh Project instance per test - isolated from Live
    const project = new Project({
      useInMemoryFileSystem: true,
      compilerOptions: {
        strict: true,
        target: 99,
        module: 99,
        moduleResolution: 100,
        declaration: true,
        skipLibCheck: true
      }
    })

    // Helper functions (same as Live)
    const addFileHeader = (sourceFile: SourceFile, title: string, description: string) => {
      sourceFile.addStatements(`/**
 * ${title}
 *
 * ${description}
 *
 * @generated This file was generated by monorepo-library-generator
 */
`)
    }

    const addInterface = (sourceFile: SourceFile, config: InterfaceConfig) => {
      const properties = config.properties.map((p) => ({
        name: p.name,
        type: p.type,
        isReadonly: p.readonly,
        hasQuestionToken: p.optional
      }))

      const methods = config.methods?.map((m) => ({
        name: m.name,
        parameters: m.params.map((p) => ({
          name: p.name,
          type: p.type,
          hasQuestionToken: p.optional
        })),
        returnType: m.returnType
      })) ?? []

      const interfaceDecl = sourceFile.addInterface({
        name: config.name,
        isExported: config.isExported ?? true,
        extends: config.extends,
        properties,
        methods
      })

      if (config.jsdoc) {
        interfaceDecl.addJsDoc({ description: config.jsdoc })
      }
    }

    const addClass = (sourceFile: SourceFile, config: ClassConfig) => {
      const properties = config.properties?.map((p) => ({
        name: p.name,
        type: p.type,
        isReadonly: p.readonly,
        hasQuestionToken: p.optional
      })) ?? []

      const methods = config.methods?.map((m) => ({
        name: m.name,
        isStatic: m.isStatic,
        isAsync: m.isAsync,
        parameters: m.params.map((p) => ({
          name: p.name,
          type: p.type,
          hasQuestionToken: p.optional
        })),
        returnType: m.returnType,
        statements: m.body
      })) ?? []

      const statics = config.statics?.map((s) => ({
        name: s.name,
        isStatic: true,
        type: s.type,
        initializer: s.value
      })) ?? []

      const classDecl = sourceFile.addClass({
        name: config.name,
        isExported: config.isExported ?? true,
        extends: config.extends,
        implements: config.implements,
        properties: [...properties, ...statics],
        methods
      })

      if (config.jsdoc) {
        classDecl.addJsDoc({ description: config.jsdoc })
      }
    }

    // Type-safe interpolation functions for each config type (same as Live)
    const interpolateContextTagConfig = (config: ContextTagConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    const interpolateTaggedErrorConfig = (config: TaggedErrorConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    const interpolateSchemaConfig = (config: SchemaConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    const interpolateInterfaceConfig = (config: InterfaceConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    const interpolateClassConfig = (config: ClassConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    const interpolateConstantConfig = (config: ConstantConfig, context: TemplateContext) =>
      interpolateDeep(config, context).pipe(Effect.catchAll(() => Effect.succeed(config)))

    const processContent = (
      sourceFile: SourceFile,
      content: ContentDefinition,
      context: TemplateContext
    ) =>
      Effect.gen(function*() {
        switch (content.type) {
          case "raw": {
            const value = interpolateSync(content.value, context)
            sourceFile.insertText(sourceFile.getEnd(), `\n${value}\n`)
            break
          }
          case "contextTag": {
            const config = yield* interpolateContextTagConfig(content.config, context)
            addContextTagClass(sourceFile, config)
            break
          }
          case "taggedError": {
            const config = yield* interpolateTaggedErrorConfig(content.config, context)
            addTaggedErrorClass(sourceFile, config)
            break
          }
          case "schema": {
            const config = yield* interpolateSchemaConfig(content.config, context)
            addSchemaDefinition(sourceFile, config)
            break
          }
          case "interface": {
            const config = yield* interpolateInterfaceConfig(content.config, context)
            addInterface(sourceFile, config)
            break
          }
          case "class": {
            const config = yield* interpolateClassConfig(content.config, context)
            addClass(sourceFile, config)
            break
          }
          case "constant": {
            const config = yield* interpolateConstantConfig(content.config, context)
            addConstExport(sourceFile, config.name, config.type, config.value, config.jsdoc)
            break
          }
          case "rpcDefinition":
          case "fragment":
            break
        }
      })

    const processSection = (
      sourceFile: SourceFile,
      section: SectionDefinition,
      context: TemplateContext
    ) =>
      Effect.gen(function*() {
        if (section.condition && !context[section.condition]) {
          return
        }
        if (section.title) {
          const title = interpolateSync(section.title, context)
          addSectionComment(sourceFile, title)
        }
        const contents = Array.isArray(section.content) ? section.content : [section.content]
        for (const content of contents) {
          yield* processContent(sourceFile, content, context)
        }
      })

    const processImports = (
      sourceFile: SourceFile,
      imports: ReadonlyArray<ImportDefinition>,
      context: TemplateContext
    ) =>
      Effect.sync(() => {
        for (const imp of imports) {
          if (imp.condition && !context[imp.condition]) {
            continue
          }
          const items = imp.items.map((item) => interpolateSync(item, context))
          const from = interpolateSync(imp.from, context)
          if (imp.isTypeOnly) {
            addTypeImport(sourceFile, from, items)
          } else if (from === "effect") {
            addEffectImports(sourceFile, items)
          } else {
            addImport(sourceFile, from, items)
          }
        }
      })

    const processConditionalContent = (
      sourceFile: SourceFile,
      content: ConditionalContent,
      context: TemplateContext
    ) =>
      Effect.gen(function*() {
        if (content.imports) {
          yield* processImports(sourceFile, content.imports, context)
        }
        for (const section of content.sections) {
          yield* processSection(sourceFile, section, context)
        }
      })

    return {
      compile: (template, context) =>
        Effect.gen(function*() {
          const startTime = Date.now()
          yield* templateCompilations.pipe(
            Metric.tagged("template_id", template.id),
            Metric.increment
          )
          const sourceFile = project.createSourceFile(`${template.id.replace("/", "-")}.ts`, "", {
            overwrite: true
          })
          const title = interpolateSync(template.meta.title, context)
          const description = interpolateSync(template.meta.description, context)
          addFileHeader(sourceFile, title, description)
          yield* processImports(sourceFile, template.imports, context)
          for (const section of template.sections) {
            yield* processSection(sourceFile, section, context)
          }
          if (template.conditionals) {
            for (const [conditionKey, content] of Object.entries(template.conditionals)) {
              if (context[conditionKey]) {
                yield* processConditionalContent(sourceFile, content, context)
              }
            }
          }
          sourceFile.formatText({ indentSize: 2, convertTabsToSpaces: true })
          const result = sourceFile.getFullText()
          const duration = Date.now() - startTime
          yield* taggedTemplateDuration(template.id).pipe(Metric.update(duration))
          return result
        }).pipe(
          Effect.catchAll((error) =>
            Effect.fail(
              new CompilationError({
                templateId: template.id,
                message: error instanceof Error ? error.message : String(error)
              })
            )
          ),
          Effect.catchAllDefect((defect) =>
            Effect.fail(
              new CompilationError({
                templateId: template.id,
                message: defect instanceof Error ? defect.message : String(defect)
              })
            )
          ),
          Effect.withSpan(`template.compile.${template.id}`, {
            attributes: { "template.id": template.id, "context.className": context.className }
          })
        ),

      getDiagnostics: (code) =>
        Effect.sync(() => {
          const sourceFile = project.createSourceFile("__check__.ts", code, { overwrite: true })
          const diagnostics = sourceFile.getPreEmitDiagnostics()
          return diagnostics.map((d) => {
            const start = d.getStart()
            const lineAndCol = start !== undefined ? sourceFile.getLineAndColumnAtPos(start) : { line: 0, column: 0 }
            return {
              line: lineAndCol.line,
              column: lineAndCol.column,
              message: d.getMessageText().toString()
            }
          })
        }),

      reset: () =>
        Effect.sync(() => {
          for (const sourceFile of project.getSourceFiles()) {
            project.removeSourceFile(sourceFile)
          }
        })
    }
  })
}
