/**
 * Template Compiler Service
 *
 * Effect-idiomatic service for compiling template definitions to TypeScript.
 * Uses Context.Tag pattern with Layer-based dependency injection.
 *
 * @module monorepo-library-generator/templates/core/compiler
 */

import { Context, Data, Effect, Layer, Metric } from 'effect'
import { Project, type SourceFile } from 'ts-morph'
import { taggedTemplateDuration, templateCompilations } from '../../infrastructure/metrics'
import {
  addConstExport,
  addContextTagClass,
  addEffectImports,
  addImport,
  addSchemaDefinition,
  addSectionComment,
  addTaggedErrorClass,
  addTypeImport
} from '../ast/effect-builders'
import { interpolateDeep, interpolateSync } from './resolver'
import type {
  ClassConfig,
  ConditionalContent,
  ConstantConfig,
  ContentDefinition,
  ContextTagConfig,
  ImportDefinition,
  InterfaceConfig,
  SchemaConfig,
  SectionDefinition,
  TaggedErrorConfig,
  TemplateContext,
  TemplateDefinition
} from './types'

// ============================================================================
// Error Types
// ============================================================================

/**
 * Template Compilation Error
 */
export class CompilationError extends Data.TaggedError('CompilationError')<{
  readonly templateId: string
  readonly message: string
  readonly diagnostics?: ReadonlyArray<{ line: number; column: number; message: string }>
}> {}

// ============================================================================
// Service Interface
// ============================================================================

/**
 * Template Compiler Service Interface
 *
 * All methods return Effect<A, E, never> - no dependencies in R.
 * Dependencies are captured at Layer construction time.
 */
interface TemplateCompilerImpl {
  /**
   * Compile a template definition to TypeScript source
   */
  readonly compile: (
    template: TemplateDefinition,
    context: TemplateContext
  ) => Effect.Effect<string, CompilationError, never>

  /**
   * Get compilation diagnostics for source code
   */
  readonly getDiagnostics: (
    code: string
  ) => Effect.Effect<ReadonlyArray<{ line: number; column: number; message: string }>, never, never>

  /**
   * Reset the compiler (clear all files)
   */
  readonly reset: () => Effect.Effect<void, never, never>
}

// ============================================================================
// Service Tag
// ============================================================================

/**
 * Template Compiler Service Tag
 *
 * Usage:
 * ```typescript
 * const program = Effect.gen(function* () {
 *   const compiler = yield* TemplateCompiler
 *   const result = yield* compiler.compile(template, context)
 *   return result
 * })
 *
 * // Provide the layer
 * program.pipe(Effect.provide(TemplateCompiler.Live))
 * ```
 */
export class TemplateCompiler extends Context.Tag('TemplateCompiler')<
  TemplateCompiler,
  TemplateCompilerImpl
>() {
  /**
   * Live implementation with ts-morph Project
   */
  static readonly Live: Layer.Layer<TemplateCompiler> = Layer.sync(TemplateCompiler, () => {
    // Capture Project instance at layer construction
    const project = new Project({
      useInMemoryFileSystem: true,
      compilerOptions: {
        strict: true,
        target: 99, // ESNext
        module: 99, // ESNext
        moduleResolution: 100, // Bundler
        declaration: true,
        skipLibCheck: true
      }
    })

    // Helper functions (pure, no this references)
    const addFileHeader = (sourceFile: SourceFile, title: string, description: string): void => {
      sourceFile.addStatements(`/**
 * ${title}
 *
 * ${description}
 *
 * @generated This file was generated by monorepo-library-generator
 */
`)
    }

    const addInterface = (sourceFile: SourceFile, config: InterfaceConfig): void => {
      const properties = config.properties.map((p) => ({
        name: p.name,
        type: p.type,
        isReadonly: p.readonly,
        hasQuestionToken: p.optional
      }))

      const methods =
        config.methods?.map((m) => ({
          name: m.name,
          parameters: m.params.map((p) => ({
            name: p.name,
            type: p.type,
            hasQuestionToken: p.optional
          })),
          returnType: m.returnType
        })) ?? []

      const interfaceDecl = sourceFile.addInterface({
        name: config.name,
        isExported: config.isExported ?? true,
        extends: config.extends,
        properties,
        methods
      })

      if (config.jsdoc) {
        interfaceDecl.addJsDoc({ description: config.jsdoc })
      }
    }

    const addClass = (sourceFile: SourceFile, config: ClassConfig): void => {
      const properties =
        config.properties?.map((p) => ({
          name: p.name,
          type: p.type,
          isReadonly: p.readonly,
          hasQuestionToken: p.optional
        })) ?? []

      const methods =
        config.methods?.map((m) => ({
          name: m.name,
          isStatic: m.isStatic,
          isAsync: m.isAsync,
          parameters: m.params.map((p) => ({
            name: p.name,
            type: p.type,
            hasQuestionToken: p.optional
          })),
          returnType: m.returnType,
          statements: m.body
        })) ?? []

      const statics =
        config.statics?.map((s) => ({
          name: s.name,
          isStatic: true,
          type: s.type,
          initializer: s.value
        })) ?? []

      const classDecl = sourceFile.addClass({
        name: config.name,
        isExported: config.isExported ?? true,
        extends: config.extends,
        implements: config.implements,
        properties: [...properties, ...statics],
        methods
      })

      if (config.jsdoc) {
        classDecl.addJsDoc({ description: config.jsdoc })
      }
    }

    const interpolateConfig = <T>(config: T, context: TemplateContext): Effect.Effect<T, never> =>
      interpolateDeep(config, context).pipe(
        Effect.catchAll((error) =>
          Effect.succeed(config).pipe(
            Effect.tap(() =>
              Effect.logWarning(
                `Interpolation failed: ${error instanceof Error ? error.message : String(error)}, using original config`
              )
            )
          )
        )
      )

    // Content processor (functional, captures helpers via closure)
    const processContent = (
      sourceFile: SourceFile,
      content: ContentDefinition,
      context: TemplateContext
    ): Effect.Effect<void, CompilationError> =>
      Effect.gen(function* () {
        switch (content.type) {
          case 'raw': {
            const value = interpolateSync(content.value, context)
            sourceFile.insertText(sourceFile.getEnd(), `\n${value}\n`)
            break
          }

          case 'contextTag': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              ContextTagConfig,
              never
            >
            addContextTagClass(sourceFile, config)
            break
          }

          case 'taggedError': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              TaggedErrorConfig,
              never
            >
            addTaggedErrorClass(sourceFile, config)
            break
          }

          case 'schema': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              SchemaConfig,
              never
            >
            addSchemaDefinition(sourceFile, config)
            break
          }

          case 'interface': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              InterfaceConfig,
              never
            >
            addInterface(sourceFile, config)
            break
          }

          case 'class': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              ClassConfig,
              never
            >
            addClass(sourceFile, config)
            break
          }

          case 'constant': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              ConstantConfig,
              never
            >
            addConstExport(sourceFile, config.name, config.type, config.value, config.jsdoc)
            break
          }

          case 'rpcDefinition':
          case 'fragment':
            // TODO: Implement in Phase 3
            break
        }
      })

    // Section processor
    const processSection = (
      sourceFile: SourceFile,
      section: SectionDefinition,
      context: TemplateContext
    ): Effect.Effect<void, CompilationError> =>
      Effect.gen(function* () {
        if (section.condition && !context[section.condition]) {
          return
        }

        if (section.title) {
          const title = interpolateSync(section.title, context)
          addSectionComment(sourceFile, title)
        }

        const contents = Array.isArray(section.content) ? section.content : [section.content]
        for (const content of contents) {
          yield* processContent(sourceFile, content, context)
        }
      })

    // Import processor
    const processImports = (
      sourceFile: SourceFile,
      imports: ReadonlyArray<ImportDefinition>,
      context: TemplateContext
    ): Effect.Effect<void, CompilationError> =>
      Effect.gen(function* () {
        for (const imp of imports) {
          if (imp.condition && !context[imp.condition]) {
            continue
          }

          const items = imp.items.map((item) => interpolateSync(item, context))
          const from = interpolateSync(imp.from, context)

          if (imp.isTypeOnly) {
            addTypeImport(sourceFile, from, items)
          } else if (from === 'effect') {
            addEffectImports(sourceFile, items)
          } else {
            addImport(sourceFile, from, items)
          }
        }
      })

    // Conditional content processor
    const processConditionalContent = (
      sourceFile: SourceFile,
      content: ConditionalContent,
      context: TemplateContext
    ): Effect.Effect<void, CompilationError> =>
      Effect.gen(function* () {
        if (content.imports) {
          yield* processImports(sourceFile, content.imports, context)
        }

        for (const section of content.sections) {
          yield* processSection(sourceFile, section, context)
        }
      })

    // Return the service implementation
    return {
      compile: (template, context) =>
        Effect.gen(function* () {
          const startTime = Date.now()

          yield* templateCompilations.pipe(
            Metric.tagged('template_id', template.id),
            Metric.increment
          )

          const sourceFile = project.createSourceFile(`${template.id.replace('/', '-')}.ts`, '', {
            overwrite: true
          })

          const title = interpolateSync(template.meta.title, context)
          const description = interpolateSync(template.meta.description, context)
          addFileHeader(sourceFile, title, description)

          yield* processImports(sourceFile, template.imports, context)

          for (const section of template.sections) {
            yield* processSection(sourceFile, section, context)
          }

          if (template.conditionals) {
            for (const [conditionKey, content] of Object.entries(template.conditionals)) {
              if (context[conditionKey]) {
                yield* processConditionalContent(sourceFile, content, context)
              }
            }
          }

          sourceFile.formatText({
            indentSize: 2,
            convertTabsToSpaces: true
          })

          const result = sourceFile.getFullText()

          const duration = Date.now() - startTime
          yield* taggedTemplateDuration(template.id).pipe(Metric.update(duration))

          return result
        }).pipe(
          Effect.catchAll((error) =>
            Effect.fail(
              new CompilationError({
                templateId: template.id,
                message: error instanceof Error ? error.message : String(error)
              })
            )
          ),
          Effect.catchAllDefect((defect) =>
            Effect.fail(
              new CompilationError({
                templateId: template.id,
                message: defect instanceof Error ? defect.message : String(defect)
              })
            )
          ),
          Effect.withSpan(`template.compile.${template.id}`, {
            attributes: {
              'template.id': template.id,
              'context.className': context.className
            }
          })
        ),

      getDiagnostics: (code) =>
        Effect.sync(() => {
          const sourceFile = project.createSourceFile('__check__.ts', code, { overwrite: true })
          const diagnostics = sourceFile.getPreEmitDiagnostics()

          return diagnostics.map((d) => {
            const start = d.getStart()
            const lineAndCol =
              start !== undefined ? sourceFile.getLineAndColumnAtPos(start) : { line: 0, column: 0 }

            return {
              line: lineAndCol.line,
              column: lineAndCol.column,
              message: d.getMessageText().toString()
            }
          })
        }),

      reset: () =>
        Effect.sync(() => {
          for (const sourceFile of project.getSourceFiles()) {
            project.removeSourceFile(sourceFile)
          }
        })
    }
  })

  /**
   * Test implementation with isolated state
   *
   * Creates a fresh Project instance per test to prevent test pollution.
   */
  static readonly Test: Layer.Layer<TemplateCompiler> = Layer.sync(TemplateCompiler, () => {
    // Fresh Project instance per test - isolated from Live
    const project = new Project({
      useInMemoryFileSystem: true,
      compilerOptions: {
        strict: true,
        target: 99,
        module: 99,
        moduleResolution: 100,
        declaration: true,
        skipLibCheck: true
      }
    })

    // Helper functions (same as Live)
    const addFileHeader = (sourceFile: SourceFile, title: string, description: string): void => {
      sourceFile.addStatements(`/**
 * ${title}
 *
 * ${description}
 *
 * @generated This file was generated by monorepo-library-generator
 */
`)
    }

    const addInterface = (sourceFile: SourceFile, config: InterfaceConfig): void => {
      const properties = config.properties.map((p) => ({
        name: p.name,
        type: p.type,
        isReadonly: p.readonly,
        hasQuestionToken: p.optional
      }))

      const methods =
        config.methods?.map((m) => ({
          name: m.name,
          parameters: m.params.map((p) => ({
            name: p.name,
            type: p.type,
            hasQuestionToken: p.optional
          })),
          returnType: m.returnType
        })) ?? []

      const interfaceDecl = sourceFile.addInterface({
        name: config.name,
        isExported: config.isExported ?? true,
        extends: config.extends,
        properties,
        methods
      })

      if (config.jsdoc) {
        interfaceDecl.addJsDoc({ description: config.jsdoc })
      }
    }

    const addClass = (sourceFile: SourceFile, config: ClassConfig): void => {
      const properties =
        config.properties?.map((p) => ({
          name: p.name,
          type: p.type,
          isReadonly: p.readonly,
          hasQuestionToken: p.optional
        })) ?? []

      const methods =
        config.methods?.map((m) => ({
          name: m.name,
          isStatic: m.isStatic,
          isAsync: m.isAsync,
          parameters: m.params.map((p) => ({
            name: p.name,
            type: p.type,
            hasQuestionToken: p.optional
          })),
          returnType: m.returnType,
          statements: m.body
        })) ?? []

      const statics =
        config.statics?.map((s) => ({
          name: s.name,
          isStatic: true,
          type: s.type,
          initializer: s.value
        })) ?? []

      const classDecl = sourceFile.addClass({
        name: config.name,
        isExported: config.isExported ?? true,
        extends: config.extends,
        implements: config.implements,
        properties: [...properties, ...statics],
        methods
      })

      if (config.jsdoc) {
        classDecl.addJsDoc({ description: config.jsdoc })
      }
    }

    const interpolateConfig = <T>(config: T, context: TemplateContext): Effect.Effect<T, never> =>
      interpolateDeep(config, context).pipe(
        Effect.catchAll((error) =>
          Effect.succeed(config).pipe(
            Effect.tap(() =>
              Effect.logWarning(
                `Interpolation failed: ${error instanceof Error ? error.message : String(error)}, using original config`
              )
            )
          )
        )
      )

    const processContent = (
      sourceFile: SourceFile,
      content: ContentDefinition,
      context: TemplateContext
    ): Effect.Effect<void, CompilationError> =>
      Effect.gen(function* () {
        switch (content.type) {
          case 'raw': {
            const value = interpolateSync(content.value, context)
            sourceFile.insertText(sourceFile.getEnd(), `\n${value}\n`)
            break
          }
          case 'contextTag': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              ContextTagConfig,
              never
            >
            addContextTagClass(sourceFile, config)
            break
          }
          case 'taggedError': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              TaggedErrorConfig,
              never
            >
            addTaggedErrorClass(sourceFile, config)
            break
          }
          case 'schema': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              SchemaConfig,
              never
            >
            addSchemaDefinition(sourceFile, config)
            break
          }
          case 'interface': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              InterfaceConfig,
              never
            >
            addInterface(sourceFile, config)
            break
          }
          case 'class': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              ClassConfig,
              never
            >
            addClass(sourceFile, config)
            break
          }
          case 'constant': {
            const config = yield* interpolateConfig(content.config, context) as Effect.Effect<
              ConstantConfig,
              never
            >
            addConstExport(sourceFile, config.name, config.type, config.value, config.jsdoc)
            break
          }
          case 'rpcDefinition':
          case 'fragment':
            break
        }
      })

    const processSection = (
      sourceFile: SourceFile,
      section: SectionDefinition,
      context: TemplateContext
    ): Effect.Effect<void, CompilationError> =>
      Effect.gen(function* () {
        if (section.condition && !context[section.condition]) {
          return
        }
        if (section.title) {
          const title = interpolateSync(section.title, context)
          addSectionComment(sourceFile, title)
        }
        const contents = Array.isArray(section.content) ? section.content : [section.content]
        for (const content of contents) {
          yield* processContent(sourceFile, content, context)
        }
      })

    const processImports = (
      sourceFile: SourceFile,
      imports: ReadonlyArray<ImportDefinition>,
      context: TemplateContext
    ): Effect.Effect<void, CompilationError> =>
      Effect.gen(function* () {
        for (const imp of imports) {
          if (imp.condition && !context[imp.condition]) {
            continue
          }
          const items = imp.items.map((item) => interpolateSync(item, context))
          const from = interpolateSync(imp.from, context)
          if (imp.isTypeOnly) {
            addTypeImport(sourceFile, from, items)
          } else if (from === 'effect') {
            addEffectImports(sourceFile, items)
          } else {
            addImport(sourceFile, from, items)
          }
        }
      })

    const processConditionalContent = (
      sourceFile: SourceFile,
      content: ConditionalContent,
      context: TemplateContext
    ): Effect.Effect<void, CompilationError> =>
      Effect.gen(function* () {
        if (content.imports) {
          yield* processImports(sourceFile, content.imports, context)
        }
        for (const section of content.sections) {
          yield* processSection(sourceFile, section, context)
        }
      })

    return {
      compile: (template, context) =>
        Effect.gen(function* () {
          const startTime = Date.now()
          yield* templateCompilations.pipe(
            Metric.tagged('template_id', template.id),
            Metric.increment
          )
          const sourceFile = project.createSourceFile(`${template.id.replace('/', '-')}.ts`, '', {
            overwrite: true
          })
          const title = interpolateSync(template.meta.title, context)
          const description = interpolateSync(template.meta.description, context)
          addFileHeader(sourceFile, title, description)
          yield* processImports(sourceFile, template.imports, context)
          for (const section of template.sections) {
            yield* processSection(sourceFile, section, context)
          }
          if (template.conditionals) {
            for (const [conditionKey, content] of Object.entries(template.conditionals)) {
              if (context[conditionKey]) {
                yield* processConditionalContent(sourceFile, content, context)
              }
            }
          }
          sourceFile.formatText({ indentSize: 2, convertTabsToSpaces: true })
          const result = sourceFile.getFullText()
          const duration = Date.now() - startTime
          yield* taggedTemplateDuration(template.id).pipe(Metric.update(duration))
          return result
        }).pipe(
          Effect.catchAll((error) =>
            Effect.fail(
              new CompilationError({
                templateId: template.id,
                message: error instanceof Error ? error.message : String(error)
              })
            )
          ),
          Effect.catchAllDefect((defect) =>
            Effect.fail(
              new CompilationError({
                templateId: template.id,
                message: defect instanceof Error ? defect.message : String(defect)
              })
            )
          ),
          Effect.withSpan(`template.compile.${template.id}`, {
            attributes: { 'template.id': template.id, 'context.className': context.className }
          })
        ),

      getDiagnostics: (code) =>
        Effect.sync(() => {
          const sourceFile = project.createSourceFile('__check__.ts', code, { overwrite: true })
          const diagnostics = sourceFile.getPreEmitDiagnostics()
          return diagnostics.map((d) => {
            const start = d.getStart()
            const lineAndCol =
              start !== undefined ? sourceFile.getLineAndColumnAtPos(start) : { line: 0, column: 0 }
            return {
              line: lineAndCol.line,
              column: lineAndCol.column,
              message: d.getMessageText().toString()
            }
          })
        }),

      reset: () =>
        Effect.sync(() => {
          for (const sourceFile of project.getSourceFiles()) {
            project.removeSourceFile(sourceFile)
          }
        })
    }
  })
}
