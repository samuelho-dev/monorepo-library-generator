/**
 * Contract Events Template Definition
 *
 * Declarative template for generating events.ts in contract libraries.
 * Contains domain event definitions using Schema.Class pattern.
 *
 * @module monorepo-library-generator/templates/definitions/contract/events
 */

import type { TemplateDefinition } from '../../core/types'

/**
 * Contract Events Template Definition
 *
 * Generates a complete events.ts file with:
 * - Base event metadata schemas
 * - Aggregate metadata for event sourcing
 * - CRUD domain events (Created, Updated, Deleted)
 * - Event union types
 */
export const contractEventsTemplate: TemplateDefinition = {
  id: 'contract/events',
  meta: {
    title: '{className} Domain Events',
    description: 'Defines all domain events for {propertyName} domain operations.',
    module: '{scope}/contract-{fileName}/events'
  },
  imports: [
    { from: 'effect', items: ['Schema'] }
  ],
  sections: [
    // Base Event Metadata Section
    {
      title: 'Base Event Metadata',
      content: {
        type: 'raw',
        value: `/**
 * Standard metadata for all events
 */
export const EventMetadata = Schema.Struct({
  /** Unique event identifier (auto-generated by database if not provided) */
  eventId: Schema.optional(Schema.UUID).annotations({
    title: "Event ID",
    description: "Unique identifier for this event - auto-generated by database"
  }),
  /** Event type identifier */
  eventType: Schema.String.annotations({
    title: "Event Type",
    description: "Name of the event type"
  }),
  /** Event version for schema evolution */
  eventVersion: Schema.Literal("1.0").annotations({
    title: "Event Version",
    description: "Event schema version for evolution"
  }),
  /** Timestamp when event occurred (defaults to current time) */
  occurredAt: Schema.optionalWith(Schema.Date, { default: () => new Date() }).annotations({
    title: "Occurred At",
    description: "UTC timestamp when the event occurred"
  }),
  /** Optional correlation ID for tracing */
  correlationId: Schema.optional(Schema.UUID).annotations({
    title: "Correlation ID",
    description: "ID to correlate related events across services"
  }),
  /** Optional causation ID (ID of event that caused this one) */
  causationId: Schema.optional(Schema.UUID).annotations({
    title: "Causation ID",
    description: "ID of the event that caused this event"
  })
}).pipe(
  Schema.annotations({
    identifier: "EventMetadata",
    title: "Event Metadata"
  })
)

export type EventMetadata = typeof EventMetadata.Type`
      }
    },

    // Aggregate Metadata Section
    {
      title: 'Aggregate Metadata',
      content: {
        type: 'raw',
        value: `/**
 * {className} aggregate metadata for event sourcing
 *
 * Includes aggregate root ID and version for optimistic concurrency.
 */
export const {className}AggregateMetadata = Schema.Struct({
  /** Aggregate root identifier */
  aggregateId: Schema.String.pipe(Schema.brand("{className}Id")).annotations({
    title: "{className} ID",
    description: "ID of the {propertyName} aggregate root"
  }),
  /** Aggregate version for optimistic concurrency */
  aggregateVersion: Schema.Number.annotations({
    title: "Aggregate Version",
    description: "Version number for optimistic locking"
  })
}).pipe(
  Schema.annotations({
    identifier: "{className}AggregateMetadata",
    title: "{className} Aggregate Metadata"
  })
)

export type {className}AggregateMetadata = typeof {className}AggregateMetadata.Type`
      }
    },

    // Domain Events Section
    {
      title: '{className} Domain Events',
      content: {
        type: 'raw',
        value: `/**
 * Event emitted when a new {propertyName} is created
 */
export class {className}CreatedEvent extends Schema.Class<{className}CreatedEvent>("{className}CreatedEvent")({
  /** Event metadata */
  metadata: EventMetadata,
  /** Aggregate metadata */
  aggregate: {className}AggregateMetadata,
  /** Event payload - the created {propertyName} data */
  payload: Schema.Struct({
    // TODO: Add fields for the created {propertyName}
    id: Schema.String.pipe(Schema.brand("{className}Id")),
    createdAt: Schema.Date
  })
}) {}

/**
 * Event emitted when a {propertyName} is updated
 */
export class {className}UpdatedEvent extends Schema.Class<{className}UpdatedEvent>("{className}UpdatedEvent")({
  /** Event metadata */
  metadata: EventMetadata,
  /** Aggregate metadata */
  aggregate: {className}AggregateMetadata,
  /** Event payload - the changes made */
  payload: Schema.Struct({
    // TODO: Add fields that were updated
    id: Schema.String.pipe(Schema.brand("{className}Id")),
    updatedAt: Schema.Date,
    changes: Schema.Record({ key: Schema.String, value: Schema.Unknown })
  })
}) {}

/**
 * Event emitted when a {propertyName} is deleted
 */
export class {className}DeletedEvent extends Schema.Class<{className}DeletedEvent>("{className}DeletedEvent")({
  /** Event metadata */
  metadata: EventMetadata,
  /** Aggregate metadata */
  aggregate: {className}AggregateMetadata,
  /** Event payload */
  payload: Schema.Struct({
    id: Schema.String.pipe(Schema.brand("{className}Id")),
    deletedAt: Schema.Date
  })
}) {}`
      }
    },

    // Event Union Types Section
    {
      title: 'Event Union Types',
      content: {
        type: 'raw',
        value: `/**
 * Union of all {className} domain events
 */
export type {className}Event =
  | {className}CreatedEvent
  | {className}UpdatedEvent
  | {className}DeletedEvent

/**
 * Schema for all {className} events (for serialization)
 */
export const {className}EventSchema = Schema.Union(
  {className}CreatedEvent,
  {className}UpdatedEvent,
  {className}DeletedEvent
)`
      }
    },

    // Event Factory Helpers Section
    {
      title: 'Event Factory Helpers',
      content: {
        type: 'raw',
        value: `/**
 * Create event metadata with defaults
 */
export function createEventMetadata(
  eventType: string,
  options?: {
    correlationId?: string
    causationId?: string
  }
) {
  return {
    eventType,
    eventVersion: "1.0",
    occurredAt: new Date(),
    ...(options?.correlationId && { correlationId: options.correlationId }),
    ...(options?.causationId && { causationId: options.causationId })
  } satisfies EventMetadata
}

/**
 * Create aggregate metadata
 *
 * Note: aggregateId is branded at the call site via Schema validation
 */
export function createAggregateMetadata(
  aggregateId: {className}AggregateMetadata["aggregateId"],
  aggregateVersion: number
) {
  return {
    aggregateId,
    aggregateVersion
  } satisfies {className}AggregateMetadata
}`
      }
    }
  ]
}

export default contractEventsTemplate
