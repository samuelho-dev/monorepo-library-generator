/**
 * Infrastructure Database Service Template Definition
 *
 * Declarative template for generating lib/service.ts for database infrastructure.
 * Specialized for database services that delegate to Kysely provider.
 *
 * @module monorepo-library-generator/templates/definitions/infra/database-service
 */

import type { TemplateDefinition } from "../../core/types"

/**
 * Infrastructure Database Service Template Definition
 *
 * Generates a database service.ts file with:
 * - Database type re-exports
 * - DatabaseService Context.Tag
 * - Query and transaction methods
 * - Live, Test, and Dev layers
 */
export const infraDatabaseServiceTemplate: TemplateDefinition = {
  id: "infra/database-service",
  meta: {
    title: "{className} Service",
    description: `Database infrastructure service that delegates to the Kysely provider.

This service wraps the Kysely provider to expose a simplified database API.
Types come from prisma-effect-kysely; the Kysely provider handles SDK integration.

Architecture:
  prisma-effect-kysely → generates DB types
  {scope}/provider-kysely → wraps Kysely SDK (Kysely Context.Tag)
  {scope}/infra-database → this service (DatabaseService)

Usage:
  const database = yield* DatabaseService;
  const users = yield* database.query((db) =>
    db.selectFrom("users").selectAll().execute()
  )`,
    module: "{scope}/infra-{fileName}/service"
  },
  imports: [
    { from: "effect", items: ["Context", "Effect", "Layer"] },
    { from: "kysely", items: ["Kysely", "Transaction"], isTypeOnly: true },
    { from: "{scope}/provider-kysely", items: ["KyselyService", "makeTestKyselyService"] },
    {
      from: "{scope}/provider-kysely",
      items: [
        "DatabaseConnectionError as ProviderConnectionError",
        "DatabaseQueryError as ProviderQueryError"
      ],
      isTypeOnly: true
    },
    { from: "{scope}/types-database", items: ["DB"], isTypeOnly: true },
    { from: "./errors", items: ["{className}ConnectionError", "{className}InternalError"] }
  ],
  sections: [
    // Re-export Database Types
    {
      title: "Re-export Database Types from types-database",
      content: {
        type: "raw",
        value: `/**
 * Re-export Database type from types-database for convenience
 *
 * The DB type is generated by prisma-effect-kysely from your Prisma schema.
 *
 * @example
 * \`\`\`typescript
 * import type { DB } from "{scope}/types-database";
 * import { {className}Service } from "{scope}/infra-database";
 *
 * // Use DB type with DatabaseService
 * const users = yield* database.query((db) =>
 *   db.selectFrom("users").selectAll().execute()
 * )
 * \`\`\`
 */
export type { DB as Database } from "{scope}/types-database"`
      }
    },
    // Service Context.Tag Definition
    {
      title: "Service Context.Tag Definition",
      content: {
        type: "raw",
        value: `/**
 * {className} Service
 *
 * Database infrastructure that delegates to the Kysely provider.
 * Provides a simplified API for data-access libraries.
 *
 * @example
 * \`\`\`typescript
 * import { {className}Service } from "{scope}/infra-database";
 *
 * const program = Effect.gen(function*() {
 *   const database = yield* {className}Service;
 *
 *   // Simple query
 *   const users = yield* database.query((db) =>
 *     db.selectFrom("users").selectAll().execute()
 *   )
 *
 *   // Transaction
 *   yield* database.transaction((db) =>
 *     Effect.gen(function*() {
 *       const user = yield* database.query(() =>
 *         db.insertInto("users")
 *           .values({ name: "John" })
 *           .returningAll()
 *           .executeTakeFirstOrThrow()
 *       )
 *       return user;
 *     })
 *   )
 * })
 *
 * const runnable = program.pipe(
 *   Effect.provide({className}Service.Live),
 *   Effect.provide(Kysely.makeLive(kyselyInstance))
 * )
 * \`\`\`
 */
export class {className}Service extends Context.Tag(
  "{scope}/infra-{fileName}/{className}Service"
)<
  {className}Service,
  {
    /**
     * Execute a database query
     */
    readonly query: <A>(
      fn: (db: Kysely<DB>) => Promise<A>
    ) => Effect.Effect<A, {className}InternalError>

    /**
     * Execute multiple queries in a transaction
     */
    readonly transaction: <A, E>(
      fn: (tx: Transaction<DB>) => Effect.Effect<A, E>
    ) => Effect.Effect<A, E | {className}InternalError>

    /**
     * Health check for database connection
     */
    readonly healthCheck: () => Effect.Effect<boolean, {className}ConnectionError>
  }
>() {
  /**
   * Live Layer - Delegates to the Kysely provider
   */
  static readonly Live = Layer.effect(
    {className}Service,
    Effect.gen(function*() {
      const kysely = yield* KyselyService<DB>()

      return {
        query: <A>(fn: (db: Kysely<DB>) => Promise<A>) =>
          kysely.query(fn).pipe(
            Effect.catchTag("DatabaseQueryError", (error: ProviderQueryError) =>
              Effect.fail(new {className}InternalError({
                message: error.message,
                cause: error
              }))
            ),
            Effect.withSpan("{className}Service.query")
          ),

        transaction: <A, E>(fn: (tx: Transaction<DB>) => Effect.Effect<A, E>) =>
          kysely.transaction(fn).pipe(
            Effect.catchTag("DatabaseTransactionError", (error) =>
              Effect.fail(new {className}InternalError({
                message: "message" in error ? error.message : "Transaction failed",
                cause: error
              }))
            ),
            Effect.withSpan("{className}Service.transaction")
          ),

        healthCheck: () =>
          kysely.ping().pipe(
            Effect.map(() => true),
            Effect.catchTag("DatabaseConnectionError", (error: ProviderConnectionError) =>
              Effect.fail(new {className}ConnectionError({
                message: "Health check failed",
                target: "database",
                cause: error
              }))
            ),
            Effect.withSpan("{className}Service.healthCheck")
          )
      }
    })
  )

  /**
   * Test Layer - Uses the Kysely provider's Test layer
   */
  static readonly Test = Layer.sync({className}Service, () => {
    const testService = makeTestKyselyService<DB>()

    return {
      query: <A>(fn: (db: Kysely<DB>) => Promise<A>) =>
        testService.query(fn).pipe(
          Effect.catchTag("DatabaseQueryError", (error: ProviderQueryError) =>
            Effect.fail(new {className}InternalError({
              message: error.message,
              cause: error
            }))
          )
        ),

      transaction: <A, E>(fn: (tx: Transaction<DB>) => Effect.Effect<A, E>) =>
        testService.transaction(fn).pipe(
          Effect.catchTag("DatabaseTransactionError", (error) =>
            Effect.fail(new {className}InternalError({
              message: "message" in error ? error.message : "Transaction failed",
              cause: error
            }))
          )
        ),

      healthCheck: () =>
        testService.ping().pipe(
          Effect.map(() => true),
          Effect.catchTag("DatabaseConnectionError", (error: ProviderConnectionError) =>
            Effect.fail(new {className}ConnectionError({
              message: "Health check failed",
              target: "database",
              cause: error
            }))
          )
        )
    }
  })

  /**
   * Dev Layer - Development with enhanced logging
   */
  static readonly Dev = Layer.effect(
    {className}Service,
    Effect.gen(function*() {
      const kysely = yield* KyselyService<DB>()

      return {
        query: <A>(fn: (db: Kysely<DB>) => Promise<A>) =>
          Effect.gen(function*() {
            yield* Effect.logDebug("[{className}Service] [DEV] Executing query")
            const result = yield* kysely.query(fn).pipe(
              Effect.catchTag("DatabaseQueryError", (error: ProviderQueryError) =>
                Effect.fail(new {className}InternalError({
                  message: error.message,
                  cause: error
                }))
              )
            )
            yield* Effect.logDebug("[{className}Service] [DEV] Query completed")
            return result
          }),

        transaction: <A, E>(fn: (tx: Transaction<DB>) => Effect.Effect<A, E>) =>
          Effect.gen(function*() {
            yield* Effect.logDebug("[{className}Service] [DEV] Starting transaction")
            const result = yield* kysely.transaction(fn).pipe(
              Effect.catchTag("DatabaseTransactionError", (error) =>
                Effect.fail(new {className}InternalError({
                  message: "message" in error ? error.message : "Transaction failed",
                  cause: error
                }))
              )
            )
            yield* Effect.logDebug("[{className}Service] [DEV] Transaction completed")
            return result
          }),

        healthCheck: () =>
          Effect.gen(function*() {
            yield* Effect.logDebug("[{className}Service] [DEV] Health check")
            return yield* kysely.ping().pipe(
              Effect.map(() => true),
              Effect.catchTag("DatabaseConnectionError", (error: ProviderConnectionError) =>
                Effect.fail(new {className}ConnectionError({
                  message: "Health check failed",
                  target: "database",
                  cause: error
                }))
              )
            )
          })
      }
    })
  )
}`
      }
    }
  ]
}

export default infraDatabaseServiceTemplate
