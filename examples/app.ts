/**
 * Complete Integration Example
 *
 * This example demonstrates all 5 layers of the architecture working together:
 *
 * 1. CONTRACT: Domain types and schemas (generated from Prisma)
 * 2. PROVIDER: External service adapters (Kysely for database)
 * 3. INFRASTRUCTURE: Service orchestration (Database service)
 * 4. DATA-ACCESS: Repository pattern (UserRepository)
 * 5. FEATURE: Business logic (UserService)
 *
 * The key is understanding Layer composition:
 * - Each layer depends on layers below it
 * - Layer.provide chains dependencies together
 * - Effect.gen accesses services via yield*
 */

import { Effect, Layer, Console } from "effect"

// ============================================================================
// LAYER 5: FEATURE (Business Logic)
// ============================================================================
//
// After running: mlg generate feature user-management
// You would have: @custom-repo/feature-user-management
//
// For now, we'll simulate the feature service:

import type { Context } from "effect"

// Simulated UserService (would come from feature library)
class UserService extends Context.Tag("UserService")<
  UserService,
  {
    readonly createUser: (email: string, name?: string) => Effect.Effect<
      { id: string; email: string; name?: string },
      Error
    >
    readonly getUserByEmail: (email: string) => Effect.Effect<
      { id: string; email: string; name?: string } | null,
      Error
    >
  }
>() {}

// ============================================================================
// LAYER 4: DATA-ACCESS (Repository Pattern)
// ============================================================================
//
// After running: mlg generate data-access user
// You would have: @custom-repo/data-access-user
//
// For now, we'll simulate the repository:

import type { DatabaseService } from "@custom-repo/infra-database"

const UserRepositoryLive = Layer.effect(
  UserService,
  Effect.gen(function* () {
    // Depend on infrastructure layer
    const db = yield* DatabaseService

    return {
      createUser: (email: string, name?: string) =>
        Effect.gen(function* () {
          yield* Console.log(`ðŸ“ Creating user: ${email}`)

          // Use database infrastructure
          const user = yield* db.create({ email, name })

          yield* Console.log(`âœ… User created: ${user.id}`)
          return user as { id: string; email: string; name?: string }
        }),

      getUserByEmail: (email: string) =>
        Effect.gen(function* () {
          yield* Console.log(`ðŸ” Finding user: ${email}`)

          // Use database infrastructure
          const result = yield* db.findByCriteria({ email }, 0, 1)

          if (result.length === 0) {
            yield* Console.log(`âŒ User not found: ${email}`)
            return null
          }

          const user = result[0] as { id: string; email: string; name?: string }
          yield* Console.log(`âœ… User found: ${user.id}`)
          return user
        })
    }
  })
)

// ============================================================================
// LAYER 3: INFRASTRUCTURE (Service Orchestration)
// ============================================================================
//
// Already generated: @custom-repo/infra-database
// Auto-imports and uses: @custom-repo/provider-kysely
//
// This layer is generated by: mlg init
// It automatically integrates with the Kysely provider

import { DatabaseService } from "@custom-repo/infra-database"

// ============================================================================
// LAYER 2: PROVIDER (External Service Adapter)
// ============================================================================
//
// Already generated: @custom-repo/provider-kysely
// Wraps Kysely SDK with Effect interface
//
// This layer is generated by: mlg init
// It provides the low-level database operations

import { Kysely } from "@custom-repo/provider-kysely"

// ============================================================================
// LAYER 1: CONTRACT (Domain Types)
// ============================================================================
//
// After creating prisma/schemas/user.prisma and running:
// pnpm prisma:generate
//
// You would have: @custom-repo/contract-user
// With: UserSchema, User type, CreateUserInput, etc.
//
// For this example, we define types inline:

// import { User, UserSchema } from "@custom-repo/contract-user"

// ============================================================================
// COMPLETE LAYER COMPOSITION
// ============================================================================

/**
 * Complete application layer
 *
 * This shows how all layers compose together:
 *
 * UserService (Feature)
 *   â†“ depends on
 * DatabaseService (Infrastructure)
 *   â†“ depends on
 * Kysely (Provider)
 *
 * Layer.provide chains them: Feature â†’ Infra â†’ Provider
 */
const AppLayer = UserRepositoryLive.pipe(
  Layer.provide(DatabaseService.Live),
  Layer.provide(Kysely.Live)
)

// ============================================================================
// EXAMPLE APPLICATION
// ============================================================================

const program = Effect.gen(function* () {
  const userService = yield* UserService

  yield* Console.log("\nðŸš€ Starting User Management Example\n")
  yield* Console.log("=" + "=".repeat(50) + "\n")

  // Create a user
  yield* Console.log("ðŸ“‹ Step 1: Create User")
  const newUser = yield* userService.createUser(
    "alice@example.com",
    "Alice Smith"
  )
  yield* Console.log(`   User ID: ${newUser.id}\n`)

  // Find the user
  yield* Console.log("ðŸ“‹ Step 2: Find User by Email")
  const foundUser = yield* userService.getUserByEmail("alice@example.com")
  if (foundUser) {
    yield* Console.log(`   Found: ${foundUser.name} (${foundUser.email})\n`)
  }

  // Try to find non-existent user
  yield* Console.log("ðŸ“‹ Step 3: Find Non-Existent User")
  const notFound = yield* userService.getUserByEmail("bob@example.com")
  yield* Console.log(`   Result: ${notFound ? "Found" : "Not found"}\n`)

  yield* Console.log("=" + "=".repeat(50))
  yield* Console.log("\nâœ… Example completed successfully!\n")

  return "Success"
})

// ============================================================================
// RUN THE APPLICATION
// ============================================================================

/**
 * Run this example:
 *
 * 1. Install dependencies:
 *    pnpm install
 *
 * 2. Build all libraries:
 *    pnpm build
 *
 * 3. Run the example:
 *    tsx examples/app.ts
 *
 * Expected output:
 * - User creation with auto-generated ID
 * - User lookup by email (success)
 * - User lookup by email (not found)
 */

// Uncomment to run:
// program.pipe(
//   Effect.provide(AppLayer),
//   Effect.runPromise
// ).then(
//   (result) => console.log("Result:", result),
//   (error) => console.error("Error:", error)
// )

/**
 * Key Takeaways:
 *
 * 1. **Layer Composition**: Use Layer.provide to chain dependencies
 * 2. **Dependency Injection**: Use yield* to access services
 * 3. **Type Safety**: All services are fully typed
 * 4. **Effect Patterns**: Use Effect.gen for sequential operations
 * 5. **Clean Architecture**: Each layer has a single responsibility
 *
 * Next Steps:
 *
 * 1. Create actual Prisma schema: prisma/schemas/user.prisma
 * 2. Generate contract: pnpm prisma:generate
 * 3. Generate data-access: mlg generate data-access user
 * 4. Generate feature: mlg generate feature user-management
 * 5. Replace simulated layers with actual generated libraries
 */

export { program, AppLayer }
