/**
 * User Domain Errors
 *
 * Defines all error types for user domain operations.
 *
 * @generated This file was generated by monorepo-library-generator
 */
import { Data } from "effect";

/**
 * ERROR TYPE SELECTION GUIDE:
 * ===========================
 *
 * 1. Data.TaggedError - For Domain & Repository Errors (DEFAULT CHOICE)
 *    Use when: Errors stay within your service boundary (same process)
 *    Benefits: Lightweight, better performance, simpler API
 *
 * 2. Schema.TaggedError - For RPC/Network Boundaries (SPECIAL CASES ONLY)
 *    Use when: Errors cross network boundaries (client â†” server RPC)
 *
 * This template uses Data.TaggedError for ALL errors (domain + repository).
 */
// ============================================================================
// Domain Errors (Data.TaggedError)
// ============================================================================

/**
 * Error thrown when user is not found
 */
export class UserNotFoundError extends Data.TaggedError(
  "UserNotFoundError"
)<{
  /** Human-readable error message */
  readonly message: string
  /** Identifier that was not found */
  readonly userId: string
}> {
  static create(userId: string) {
    return new UserNotFoundError({
      message: `User not found: ${userId}`,
      userId
    })
  }
}

/**
 * Error thrown when user validation fails
 */
export class UserValidationError extends Data.TaggedError(
  "UserValidationError"
)<{
  /** Human-readable error message */
  readonly message: string
  /** Field that failed validation */
  readonly field?: string
  /** Constraint that was violated */
  readonly constraint?: string
  /** Invalid value */
  readonly value?: unknown
}> {
  static create(params: {
    message: string
    field?: string
    constraint?: string
    value?: unknown
  }) {
    return new UserValidationError({
      message: params.message,
      ...(params.field !== undefined && { field: params.field }),
      ...(params.constraint !== undefined && { constraint: params.constraint }),
      ...(params.value !== undefined && { value: params.value })
    })
  }

  static fieldRequired(field: string) {
    return new UserValidationError({
      message: `${field} is required`,
      field,
      constraint: "required"
    })
  }

  static fieldInvalid(field: string, constraint: string, value?: unknown) {
    return new UserValidationError({
      message: `${field} is invalid: ${constraint}`,
      field,
      constraint,
      ...(value !== undefined && { value })
    })
  }
}

/**
 * Error thrown when user already exists
 */
export class UserAlreadyExistsError extends Data.TaggedError(
  "UserAlreadyExistsError"
)<{
  /** Human-readable error message */
  readonly message: string
  /** Identifier of existing resource */
  readonly identifier?: string
}> {
  static create(identifier?: string) {
    return new UserAlreadyExistsError({
      message: identifier
        ? `User already exists: ${identifier}`
        : "User already exists",
      ...(identifier !== undefined && { identifier })
    })
  }
}

/**
 * Error thrown when user operation is not permitted
 */
export class UserPermissionError extends Data.TaggedError(
  "UserPermissionError"
)<{
  /** Human-readable error message */
  readonly message: string
  /** Operation that was denied */
  readonly operation: string
  /** Resource identifier */
  readonly userId: string
}> {
  static create(params: {
    operation: string
    userId: string
  }) {
    return new UserPermissionError({
      message: `Operation '${params.operation}' not permitted on user ${params.userId}`,
      operation: params.operation,
      userId: params.userId
    })
  }
}

/**
 * Union of all domain errors
 */
export type UserDomainError =
  | UserNotFoundError
  | UserValidationError
  | UserAlreadyExistsError
  | UserPermissionError
// ============================================================================
// Repository Errors (Data.TaggedError)
// ============================================================================

/**
 * Repository error for user not found
 */
export class UserNotFoundRepositoryError extends Data.TaggedError(
  "UserNotFoundRepositoryError"
)<{
  /** Human-readable error message */
  readonly message: string
  /** Identifier that was not found */
  readonly userId: string
}> {
  static create(userId: string) {
    return new UserNotFoundRepositoryError({
      message: `User not found: ${userId}`,
      userId
    })
  }
}

/**
 * Repository error for user validation failures
 */
export class UserValidationRepositoryError extends Data.TaggedError(
  "UserValidationRepositoryError"
)<{
  /** Human-readable error message */
  readonly message: string
  /** Field that failed validation */
  readonly field?: string
  /** Constraint that was violated */
  readonly constraint?: string
}> {
  static create(params: {
    message: string
    field?: string
    constraint?: string
  }) {
    return new UserValidationRepositoryError({
      message: params.message,
      ...(params.field !== undefined && { field: params.field }),
      ...(params.constraint !== undefined && { constraint: params.constraint })
    })
  }
}

/**
 * Repository error for user conflicts
 */
export class UserConflictRepositoryError extends Data.TaggedError(
  "UserConflictRepositoryError"
)<{
  /** Human-readable error message */
  readonly message: string
  /** Identifier of conflicting resource */
  readonly identifier?: string
}> {
  static create(identifier?: string) {
    return new UserConflictRepositoryError({
      message: identifier
        ? `User already exists: ${identifier}`
        : "User already exists",
      ...(identifier !== undefined && { identifier })
    })
  }
}

/**
 * Repository error for user database failures
 */
export class UserDatabaseRepositoryError extends Data.TaggedError(
  "UserDatabaseRepositoryError"
)<{
  /** Human-readable error message */
  readonly message: string
  /** Database operation that failed */
  readonly operation: string
  /** Underlying database error */
  readonly cause?: string
}> {
  static create(params: {
    message: string
    operation: string
    cause?: string
  }) {
    return new UserDatabaseRepositoryError({
      message: params.message,
      operation: params.operation,
      ...(params.cause !== undefined && { cause: params.cause })
    })
  }
}

/**
 * Union of all repository errors
 */
export type UserRepositoryError =
  | UserNotFoundRepositoryError
  | UserValidationRepositoryError
  | UserConflictRepositoryError
  | UserDatabaseRepositoryError
// ============================================================================
// Error Union Types
// ============================================================================

/**
 * All possible user errors
 */
export type UserError = UserDomainError | UserRepositoryError
