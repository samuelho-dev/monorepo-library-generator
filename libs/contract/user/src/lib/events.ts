import { Schema } from "effect"
import type { UserId } from "./rpc-definitions"

/**
 * User Domain Events
 *
 * Defines domain events for user operations.
 * Events are used for event-driven architecture and messaging.
 *
 * @see https://effect.website/docs/schema/schema for Schema patterns
 * @module @samuelho-dev/contract-user/events
 */


// ============================================================================
// Base Event Metadata
// ============================================================================


/**
 * Standard metadata for all events
 */
export const EventMetadata = Schema.Struct({
  /** Unique event identifier (auto-generated by database if not provided) */
  eventId: Schema.optional(Schema.UUID).annotations({
    title: "Event ID",
    description: "Unique identifier for this event - auto-generated by database"
  }),

  /** Event type identifier */
  eventType: Schema.String.annotations({
    title: "Event Type",
    description: "Name of the event type"
  }),

  /** Event version for schema evolution */
  eventVersion: Schema.Literal("1.0").annotations({
    title: "Event Version",
    description: "Event schema version for evolution"
  }),

  /** Timestamp when event occurred (defaults to current time) */
  occurredAt: Schema.optionalWith(Schema.Date, { default: () => new Date() }).annotations({
    title: "Occurred At",
    description: "UTC timestamp when the event occurred"
  }),

  /** Optional correlation ID for tracing */
  correlationId: Schema.optional(Schema.UUID).annotations({
    title: "Correlation ID",
    description: "ID to correlate related events across services"
  }),

  /** Optional causation ID (ID of event that caused this one) */
  causationId: Schema.optional(Schema.UUID).annotations({
    title: "Causation ID",
    description: "ID of the event that caused this event"
  }),
}).pipe(
  Schema.annotations({
    identifier: "EventMetadata",
    title: "Event Metadata",
    description: "Standard metadata included in all domain events"
  })
);


/**
 * Aggregate metadata for events tied to an aggregate root
 */
export const AggregateMetadata = Schema.Struct({
  /** Aggregate root identifier */
  aggregateId: Schema.UUID.annotations({
    title: "Aggregate ID",
    description: "Identifier of the aggregate root this event belongs to"
  }),

  /** Aggregate type */
  aggregateType: Schema.Literal("User").annotations({
    title: "Aggregate Type",
    description: "Type name of the aggregate root"
  }),

  /** Aggregate version for optimistic concurrency */
  aggregateVersion: Schema.Number.pipe(
    Schema.int(),
    Schema.positive()
  ).annotations({
    title: "Aggregate Version",
    description: "Version number for optimistic concurrency control",
    jsonSchema: { minimum: 1 }
  }),
}).pipe(
  Schema.annotations({
    identifier: "AggregateMetadata",
    title: "Aggregate Metadata",
    description: "Metadata for event sourcing and aggregate tracking"
  })
);


// ============================================================================
// CRUD Domain Events
// ============================================================================


/**
 * Event emitted when a user is created
 */
export class UserCreatedEvent extends Schema.Class<UserCreatedEvent>(
  "UserCreatedEvent"
)({
  ...EventMetadata.fields,
  ...AggregateMetadata.fields,

  /** User identifier */
  userId: Schema.UUID.annotations({
    title: "User ID",
    description: "ID of the user that was created"
  }),

  /** User who created the user */
  createdBy: Schema.optional(Schema.UUID).annotations({
    title: "Created By",
    description: "UUID of the user who created this user"
  })
}) {
  /**
   * Create a new UserCreatedEvent
   *
   * Note: eventId and occurredAt are auto-generated if not provided
   */
  static create(params: {
    userId: UserId;
    aggregateId?: string;
    createdBy?: string;
    correlationId?: string;
  }) {
    return new UserCreatedEvent({
      eventType: "UserCreatedEvent",
      eventVersion: "1.0",
      aggregateId: params.aggregateId ?? params.userId,
      aggregateType: "User",
      aggregateVersion: 1,
      userId: params.userId,
      ...(params.createdBy && { createdBy: params.createdBy }),
      ...(params.correlationId && { correlationId: params.correlationId }),
    });
  }
}

/**
 * Event emitted when a user is updated
 */
export class UserUpdatedEvent extends Schema.Class<UserUpdatedEvent>(
  "UserUpdatedEvent"
)({
  ...EventMetadata.fields,
  ...AggregateMetadata.fields,

  /** User identifier */
  userId: Schema.UUID.annotations({
    title: "User ID",
    description: "ID of the user that was updated"
  }),

  /** User who updated the user */
  updatedBy: Schema.optional(Schema.UUID).annotations({
    title: "Updated By",
    description: "UUID of the user who updated this user"
  }),

  /** Fields that were changed (optional) */
  changedFields: Schema.optional(Schema.Array(Schema.String)).annotations({
    title: "Changed Fields",
    description: "List of field names that were modified"
  })
}) {
  /**
   * Create a new UserUpdatedEvent
   *
   * Note: eventId and occurredAt are auto-generated if not provided
   */
  static create(params: {
    userId: UserId;
    aggregateVersion: number;
    aggregateId?: string;
    updatedBy?: string;
    changedFields?: Array<string>;
    correlationId?: string;
  }) {
    return new UserUpdatedEvent({
      eventType: "UserUpdatedEvent",
      eventVersion: "1.0",
      aggregateId: params.aggregateId ?? params.userId,
      aggregateType: "User",
      aggregateVersion: params.aggregateVersion,
      userId: params.userId,
      ...(params.updatedBy && { updatedBy: params.updatedBy }),
      ...(params.changedFields && { changedFields: params.changedFields }),
      ...(params.correlationId && { correlationId: params.correlationId }),
    });
  }
}

/**
 * Event emitted when a user is deleted
 */
export class UserDeletedEvent extends Schema.Class<UserDeletedEvent>(
  "UserDeletedEvent"
)({
  ...EventMetadata.fields,
  ...AggregateMetadata.fields,

  /** User identifier */
  userId: Schema.UUID.annotations({
    title: "User ID",
    description: "ID of the user that was deleted"
  }),

  /** User who deleted the user */
  deletedBy: Schema.optional(Schema.UUID).annotations({
    title: "Deleted By",
    description: "UUID of the user who deleted this user"
  }),

  /** Whether this was a soft delete */
  isSoftDelete: Schema.optional(Schema.Boolean).annotations({
    title: "Soft Delete",
    description: "True if this was a soft delete (marked as deleted but not removed)"
  })
}) {
  /**
   * Create a new UserDeletedEvent
   *
   * Note: eventId and occurredAt are auto-generated if not provided
   */
  static create(params: {
    userId: UserId;
    aggregateVersion: number;
    aggregateId?: string;
    deletedBy?: string;
    isSoftDelete?: boolean;
    correlationId?: string;
  }) {
    return new UserDeletedEvent({
      eventType: "UserDeletedEvent",
      eventVersion: "1.0",
      aggregateId: params.aggregateId ?? params.userId,
      aggregateType: "User",
      aggregateVersion: params.aggregateVersion,
      userId: params.userId,
      ...(params.deletedBy && { deletedBy: params.deletedBy }),
      ...(params.isSoftDelete !== undefined && { isSoftDelete: params.isSoftDelete }),
      ...(params.correlationId && { correlationId: params.correlationId }),
    });
  }
}

// ============================================================================
// Event Union Types
// ============================================================================


/**
 * Union of all user domain events
 */
export type UserDomainEvent = 
  | UserCreatedEvent
  | UserUpdatedEvent
  | UserDeletedEvent

