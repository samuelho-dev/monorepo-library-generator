import { KyselyService, makeTestKyselyService } from "@samuelho-dev/provider-kysely"
import type { DatabaseConnectionError as ProviderConnectionError, DatabaseQueryError as ProviderQueryError } from "@samuelho-dev/provider-kysely"
import type { DB } from "@samuelho-dev/types-database"
import { Context, Effect, Layer } from "effect"
import type { Kysely, Transaction } from "kysely"
import { DatabaseConnectionError, DatabaseInternalError } from "./errors"

/**
 * Database Service
 *
 * Database infrastructure service that delegates to the Kysely provider.

This service wraps the Kysely provider to expose a simplified database API.
Types come from prisma-effect-kysely; the Kysely provider handles SDK integration.

Architecture:
  prisma-effect-kysely → generates DB types
  @samuelho-dev/provider-kysely → wraps Kysely SDK (Kysely Context.Tag)
  @samuelho-dev/infra-database → this service (DatabaseService)

Usage:
  const database = yield* DatabaseService;
  const users = yield* database.query((db) =>
    db.selectFrom("users").selectAll().execute()
  );
 *
 * @module @samuelho-dev/infra-database/service
 * @see EFFECT_PATTERNS.md for database patterns
 */
// ============================================================================
// Re-export Database Types from types-database
// ============================================================================
/**
 * Re-export Database type from types-database for convenience
 *
 * The DB type is generated by prisma-effect-kysely from your Prisma schema.
 *
 * @example
 * ```typescript
 * import type { DB } from "@samuelho-dev/types-database";
 * import { DatabaseService } from "@samuelho-dev/infra-database";
 *
 * // Use DB type with DatabaseService
 * const users = yield* database.query((db) =>
 *   db.selectFrom("users").selectAll().execute()
 * );
 * ```
 */
export type { DB as Database } from "@samuelho-dev/types-database"

// ============================================================================
// Service Context.Tag Definition
// ============================================================================
/**
 * Database Service
 *
 * Database infrastructure that delegates to the Kysely provider.
 * Provides a simplified API for data-access libraries.
 *
 * @example
 * ```typescript
 * import { DatabaseService } from "@samuelho-dev/infra-database";
 *
 * const program = Effect.gen(function*() {
 *   const database = yield* DatabaseService;
 *
 *   // Simple query
 *   const users = yield* database.query((db) =>
 *     db.selectFrom("users").selectAll().execute()
 *   );
 *
 *   // Query with filtering
 *   const activeUsers = yield* database.query((db) =>
 *     db.selectFrom("users")
 *       .selectAll()
 *       .where("status", "=", "active")
 *       .execute()
 *   );
 *
 *   // Transaction
 *   yield* database.transaction((db) =>
 *     Effect.gen(function*() {
 *       const user = yield* database.query(() =>
 *         db.insertInto("users")
 *           .values({ name: "John" })
 *           .returningAll()
 *           .executeTakeFirstOrThrow()
 *       );
 *       yield* database.query(() =>
 *         db.insertInto("audit_logs")
 *           .values({ userId: user.id, action: "created" })
 *           .execute()
 *       );
 *       return user;
 *     })
 *   );
 * });
 *
 * // Provide layers
 * const runnable = program.pipe(
 *   Effect.provide(DatabaseService.Live),
 *   Effect.provide(Kysely.makeLive(kyselyInstance))
 * );
 * ```
 */
export class DatabaseService extends Context.Tag(
  "@samuelho-dev/infra-database/DatabaseService"
)<
  DatabaseService,
  {
    /**
     * Execute a database query
     *
     * Delegates to the Kysely provider's query method.
     * Uses top-level type imports to preserve Kysely's type inference.
     *
     * @param fn - Query builder function that receives the Kysely instance
     * @returns Effect that succeeds with the query result
     */
    readonly query: <A>(
      fn: (db: Kysely<DB>) => Promise<A>
    ) => Effect.Effect<A, DatabaseInternalError>

    /**
     * Execute multiple queries in a transaction
     *
     * All queries within the transaction share the same connection.
     * If any query fails, the entire transaction is rolled back.
     *
     * @param fn - Effect that performs database operations within transaction scope
     * @returns Effect that succeeds with the transaction result
     */
    readonly transaction: <A, E>(
      fn: (tx: Transaction<DB>) => Effect.Effect<A, E>
    ) => Effect.Effect<A, E | DatabaseInternalError>

    /**
     * Health check for database connection
     *
     * @returns Effect that succeeds with true if database is healthy
     */
    readonly healthCheck: () => Effect.Effect<boolean, DatabaseConnectionError>
  }
>() {
  // ===========================================================================
  // Static Live Layer - Delegates to Kysely Provider
  // ===========================================================================

  /**
   * Live Layer - Delegates to the Kysely provider
   *
   * Requires Kysely layer to be provided.
   *
   * @example
   * ```typescript
   * import { Kysely, PostgresDialect } from "kysely";
   * import { Pool } from "pg";
   * import { Kysely as KyselyProvider } from "@samuelho-dev/provider-kysely";
   *
   * const pool = new Pool({ connectionString: process.env.DATABASE_URL });
   * const kyselyInstance = new Kysely({ dialect: new PostgresDialect({ pool }) });
   *
   * const program = myProgram.pipe(
   *   Effect.provide(DatabaseService.Live),
   *   Effect.provide(KyselyProvider.makeLive(kyselyInstance))
   * );
   * ```
   */
  static readonly Live = Layer.effect(
    DatabaseService,
    Effect.gen(function*() {
      const kysely = yield* KyselyService<DB>()

      return {
        query: <A>(fn: (db: Kysely<DB>) => Promise<A>) =>
          kysely.query(fn).pipe(
            Effect.catchTag("DatabaseQueryError", (error: ProviderQueryError) =>
              Effect.fail(new DatabaseInternalError({
                message: error.message,
                cause: error
              }))
            ),
            Effect.withSpan("DatabaseService.query")
          ),

        transaction: <A, E>(fn: (tx: Transaction<DB>) => Effect.Effect<A, E>) =>
          kysely.transaction(fn).pipe(
            Effect.catchTag("DatabaseTransactionError", (error) =>
              Effect.fail(new DatabaseInternalError({
                message: "message" in error ? error.message : "Transaction failed",
                cause: error
              }))
            ),
            Effect.withSpan("DatabaseService.transaction")
          ),

        healthCheck: () =>
          kysely.ping().pipe(
            Effect.map(() => true),
            Effect.catchTag("DatabaseConnectionError", (error: ProviderConnectionError) =>
              Effect.fail(new DatabaseConnectionError({
                message: "Health check failed",
                target: "database",
                cause: error
              }))
            ),
            Effect.withSpan("DatabaseService.healthCheck")
          )
      }
    })
  )

  // ===========================================================================
  // Static Test Layer - Delegates to Kysely Provider Test Layer
  // ===========================================================================

  /**
   * Test Layer - Uses the Kysely provider's Test layer
   *
   * Provides an in-memory mock database for testing.
   * No external database connection required.
   */
  static readonly Test = Layer.sync(DatabaseService, () => {
    // Use provider's test service with DummyDriver for proper Kysely testing
    const testService = makeTestKyselyService<DB>()

    return {
      query: <A>(fn: (db: Kysely<DB>) => Promise<A>) =>
        testService.query(fn).pipe(
          Effect.catchTag("DatabaseQueryError", (error: ProviderQueryError) =>
            Effect.fail(new DatabaseInternalError({
              message: error.message,
              cause: error
            }))
          )
        ),

      transaction: <A, E>(fn: (tx: Transaction<DB>) => Effect.Effect<A, E>) =>
        testService.transaction(fn).pipe(
          Effect.catchTag("DatabaseTransactionError", (error) =>
            Effect.fail(new DatabaseInternalError({
              message: "message" in error ? error.message : "Transaction failed",
              cause: error
            }))
          )
        ),

      healthCheck: () =>
        testService.ping().pipe(
          Effect.map(() => true),
          Effect.catchTag("DatabaseConnectionError", (error: ProviderConnectionError) =>
            Effect.fail(new DatabaseConnectionError({
              message: "Health check failed",
              target: "database",
              cause: error
            }))
          )
        )
    }
  })

  // ===========================================================================
  // Static Dev Layer - Uses Kysely Provider with Logging
  // ===========================================================================

  /**
   * Dev Layer - Development with enhanced logging
   *
   * Uses the Kysely provider's Test layer with debug logging enabled.
   */
  static readonly Dev = Layer.effect(
    DatabaseService,
    Effect.gen(function*() {
      const kysely = yield* KyselyService<DB>()

      return {
        query: <A>(fn: (db: Kysely<DB>) => Promise<A>) =>
          Effect.gen(function*() {
            yield* Effect.logDebug("[DatabaseService] [DEV] Executing query")
            const result = yield* kysely.query(fn).pipe(
              Effect.catchTag("DatabaseQueryError", (error: ProviderQueryError) =>
                Effect.fail(new DatabaseInternalError({
                  message: error.message,
                  cause: error
                }))
              )
            )
            yield* Effect.logDebug("[DatabaseService] [DEV] Query completed")
            return result
          }),

        transaction: <A, E>(fn: (tx: Transaction<DB>) => Effect.Effect<A, E>) =>
          Effect.gen(function*() {
            yield* Effect.logDebug("[DatabaseService] [DEV] Starting transaction")
            const result = yield* kysely.transaction(fn).pipe(
              Effect.catchTag("DatabaseTransactionError", (error) =>
                Effect.fail(new DatabaseInternalError({
                  message: "message" in error ? error.message : "Transaction failed",
                  cause: error
                }))
              )
            )
            yield* Effect.logDebug("[DatabaseService] [DEV] Transaction completed")
            return result
          }),

        healthCheck: () =>
          Effect.gen(function*() {
            yield* Effect.logDebug("[DatabaseService] [DEV] Health check")
            return yield* kysely.ping().pipe(
              Effect.map(() => true),
              Effect.catchTag("DatabaseConnectionError", (error: ProviderConnectionError) =>
                Effect.fail(new DatabaseConnectionError({
                  message: "Health check failed",
                  target: "database",
                  cause: error
                }))
              )
            )
          })
      }
    })
  )
}
